!===============================================================================
!	SOLVE 2D WATER WAVE PROBLEM WITH ONE SIDE WAVEMAKER AND ONESIDE FREE BY BEM
!	WEN-HAUI TSAO 2021 LSU
!===============================================================================
      PROGRAM FSI_PMTLD_IN_WAVE
      IMPLICIT NONE
	  INTEGER I,J,IR,IL,NT,ITR,NGA,NTIM
	  REAL*8 PI,TIME,DELTTIME,P_ATM,WC1,WC2,E1,E1_1,E1_2,E2,E1TOL,E2TOL,EA(3),D_OUT,GRAV
      REAL*8 T_START,T_INITIAL,T_STEP,T_END
	  REAL*8,ALLOCATABLE::WT(:),RT(:),SHA1(:),SHA2(:),SH(:,:)

!---CLAIM FOR WAVE
      INTEGER NPL,NFL,NBT,NNODE,NELM,NFIELD,ICON,NITER,NWG,CTYPE
      INTEGER DORTYP1,DORTYP2,WAVTYP1,WAVTYP2
	  INTEGER,ALLOCATABLE::NELEM(:),ME(:),NS(:),BUNTYP(:),LN(:,:)      
      REAL*8 DEP,MU,WIDTH,THO,WGX(10),WGY(10)
      REAL*8 AMP1,OMEGA1,PSI1,DIS1,VEL1,ACC1,AMP2,OMEGA2,PSI2,DIS2,VEL2,ACC2
      REAL*8 KE0,PE0,TE0,WORK0,DTDT0,DVDT0,DEDT0,DWDT0,PE_I0
	  REAL*8,ALLOCATABLE::COOR(:,:),SIDE_L(:)
	  REAL*8,ALLOCATABLE::NODE(:,:),NORM(:,:),JCB(:),LENG(:),PHI(:),PPHI(:),PHIT(:),PPHIT(:)
	  REAL*8,ALLOCATABLE::KER1(:,:),KER2(:,:),DP(:,:),DPDS(:),D2PDT(:),D2P(:,:)
      REAL*8,ALLOCATABLE::PR(:),DPDT(:),ACCMO(:),PHIT_TEMP(:)
      REAL*8,ALLOCATABLE::G1(:,:),H1(:,:),EYE(:)
      REAL*8,ALLOCATABLE::NODE_TEMP(:,:),NODE_PC(:,:),PHI_PC(:)
	  REAL*8,ALLOCATABLE::DI1(:),VE1(:),AC1(:),DI2(:),VE2(:),AC2(:)
      
!---CLAIM FOR PMTLD
      INTEGER TLD_YN,NDOFTLD,NNODE2,NELM2,NELEM2(4),ME2(4),NS2(4),BUNTYP2(4),ICON2
      INTEGER,ALLOCATABLE::LN2(:,:)
      REAL*8 KE2,PE2,TE2,WORK2,DTDT2,DVDT2,DEDT2,DWDT2,PE_I2,WG1_TLD,WG2_TLD,LDP1,LDP2,LDPH1,LDPH2
      REAL*8 DEP2,POR,MU1,MU2,TL,TH,TMW,TWN,COOR2(4,2),FOR2(3),TLDLOC(2)
      REAL*8 MFIX,HFIX,IFIX,A(8)
      REAL*8,ALLOCATABLE::NODE2(:,:),PHI2(:),NODE2_TEMP(:,:)
      REAL*8,ALLOCATABLE::EQM(:),EQC(:),EQK(:),EQH(:)
      REAL*8,ALLOCATABLE::M_ALL1(:,:),C_ALL1(:,:),K_ALL1(:,:),K_EFF1(:,:)
      REAL*8,ALLOCATABLE::EQZ0(:),EQZ1(:),EQZ2(:),EQZ0_PC(:),EQZ1_PC(:),EQZ2_PC(:),X0_IC(:)
      REAL*8,ALLOCATABLE::B1(:),B2(:)
      REAL*8,ALLOCATABLE::M_ALL2(:,:),C_ALL2(:,:),K_ALL2(:,:),K_EFF2(:,:)
      REAL*8,ALLOCATABLE::XN0(:),XN1(:),XN2(:)
      REAL*8,ALLOCATABLE::B3(:),B4(:)
      
!---CLAIM FOR BODY
      INTEGER IDOF(3),NDOF
      REAL*8 GAMMA,BETA,PC,BLX,BLY,THOB,MB,IB
      REAL*8 KE1,PE1,TE1,WORK1,DTDT1,DVDT1,DEDT1,DWDT1,PE_I1
	  REAL*8 RBC(5,2),COG(2),G_COOR(2),CLV(2),CRV(2),R0_IC(3)
      REAL*8 FOR(3),FOR_PC(3),FOR_TEMP(3)
	  REAL*8,ALLOCATABLE::Z0(:),Z1(:),Z2(:),Z0_PC(:),Z1_PC(:),Z2_PC(:),Z2_TEMP(:),Z0_IC(:)
!      REAL*8,ALLOCATABLE::AD(:,:),ED(:),BD(:)
            
!---SET INITIAL WALL TIME
!      CALL get_walltime(T_START)
      PI=DACOS(-1.D0)
      OPEN(UNIT=1,FILE='1.ipt',STATUS='OLD')! input file
      OPEN(UNIT=2,FILE='2.ipt',STATUS='OLD')! input file
      OPEN(UNIT=3,FILE='3.ipt',STATUS='OLD')! input file
      OPEN(UNIT=4,FILE='4.ipt',STATUS='OLD')! input file
      OPEN(UNIT=5,FILE='IO.DAT')            ! movement of both walls
      OPEN(UNIT=61,FILE='S_wave.DAT')       ! boundary of wave field
      OPEN(UNIT=62,FILE='S_tld.DAT')        ! boundary of TLD domain
      OPEN(UNIT=71,FILE='WG_wave.DAT')      ! wave gauge at wave field
      OPEN(UNIT=72,FILE='WG_tld.DAT')       ! wave gauge at TLD domain
      OPEN(UNIT=81,FILE='P.DAT')            ! local dynamic pressure concentration on the walls
      OPEN(UNIT=9,FILE='F.DAT')             ! force and momnet of wave/TLD/total
      OPEN(UNIT=10,FILE='Z.DAT')            ! displ, vel, acc of body in three directions
      OPEN(UNIT=11,FILE='RB.DAT')           ! corner node and center of gravity of body
      OPEN(UNIT=13,FILE='E.DAT')            ! energy of wave, body, and TLD
      OPEN(UNIT=14,FILE='W.DAT')            ! power of wave, body, and TLD
	  OPEN(UNIT=20,FILE='code.log')         ! log of code
	  OPEN(UNIT=21,FILE='ITER.DAT')         ! iteration times and error of radiation and FSI
!	  OPEN(UNIT=23,FILE='CFL.DAT')
!	  OPEN(UNIT=24,FILE='PATM.DAT')
	  OPEN(UNIT=31,FILE='IC_config.DAT')    ! parameters and configuration
      OPEN(UNIT=32,FILE='IC_bound.DAT')     ! initial boundary
      OPEN(UNIT=99,FILE='TEST.TXT')         ! only for temporary use

!---TOPOGRAGHY AND WAVE TYPE AND BODY CONFIGURATION
	CALL INPUT_2(NPL,NFL,NBT,DORTYP1,DORTYP2,WAVTYP1,WAVTYP2,AMP1,OMEGA1,PSI1,AMP2,OMEGA2,PSI2,&
                &NWG,WGX,NDOF,BLX,BLY,THOB,MB,IB,R0_IC,IDOF)
	ALLOCATE(NELEM(NPL),ME(NPL),NS(NPL),BUNTYP(NPL),COOR(NPL,2),SIDE_L(NPL))
    ALLOCATE(Z0(3*NDOF),Z1(3*NDOF),Z2(3*NDOF),Z0_PC(3*NDOF),Z1_PC(3*NDOF),Z2_PC(3*NDOF),Z2_TEMP(3*NDOF),Z0_IC(3*NDOF)) !,AD(6*NDOF,6*NDOF),ED(6*NDOF),BD(6*NDOF)
	NELEM=0
	NS=0
	BUNTYP=0
	COOR=0.D0
	SIDE_L=0.D0
    Z0=0.D0
    Z1=0.D0
    Z2=0.D0
    Z0_PC=0.D0
    Z1_PC=0.D0
    Z2_PC=0.D0
    Z2_TEMP=0.D0
    Z0_IC=0.D0
!    AD=0.D0
!    ED=0.D0
!    BD=0.D0
!    READ(4,*)  ((AD(I,J),J=1,6*NDOF),I=1,6*NDOF)
!    READ(4,*)  ((ED(I),I=1,6*NDOF)
    
!---INPUT PARAMETERS OF THE WAVE CHANNEL
	CALL INPUT_1(NPL,NFL,COOR,NFIELD,NNODE,NELM,NELEM,ME,NS,BUNTYP,NGA,&
               &GRAV,MU,WIDTH,THO,NTIM,DELTTIME,GAMMA,BETA,PC,ICON,&
               &NITER,E1TOL,E2TOL,CTYPE,DEP,BLX,BLY,G_COOR,CLV,CRV)
    ALLOCATE(LN(NELM,2),NODE(NNODE,2),NODE_TEMP(NNODE,2),NODE_PC(NNODE,2),NORM(NELM,2),JCB(NELM),LENG(NELM))
    ALLOCATE(PHI(NNODE),PHI_PC(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE))
	ALLOCATE(KER1(NNODE,NNODE),KER2(NNODE,NNODE))
    ALLOCATE(DP(NNODE,2),D2PDT(NNODE),D2P(NNODE,2))
    ALLOCATE(G1(NNODE,NNODE),H1(NNODE,NNODE),EYE(NNODE))
	ALLOCATE(DPDS(NNODE),DPDT(NNODE),PR(NNODE),ACCMO(NNODE),PHIT_TEMP(NNODE))
	ALLOCATE(WT(NGA),RT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA))
	ALLOCATE(DI1(NTIM),VE1(NTIM),AC1(NTIM),DI2(NTIM),VE2(NTIM),AC2(NTIM))
	LN=0
	NODE=0.D0
    NODE_TEMP=0.D0
    NODE_PC=0.D0
	NORM=0.D0
	JCB=0.D0
	LENG=0.D0
	PHI=0.D0
    PHI_PC=0.D0
	PPHI=0.D0
	PHIT=0.D0
	PPHIT=0.D0
	KER1=0.D0
	KER2=0.D0
	DP=0.D0
	DPDS=0.D0
	DPDT=0.D0
    D2PDT=0.D0
    D2P=0.D0
	PR=0.D0
	ACCMO=0.D0
	PHIT_TEMP=0.D0
	WT=0.D0
	RT=0.D0
	SHA1=0.D0
	SHA2=0.D0
	SH=0.D0
	DI1=0.D0
	VE1=0.D0
	AC1=0.D0
	DI2=0.D0
	VE2=0.D0
	AC2=0.D0
    G1=0.D0
    H1=0.D0
    EYE=1.D0

!---INPUT PARAMETERS OF THE SLOSHING TANK
    CALL INPUT_3(TLD_YN,NDOFTLD,COOR2,NNODE2,NELM2,NELEM2,ME2,NS2,BUNTYP2,MU1,MU2,POR,ICON2,TL,TH,TMW,TWN,TLDLOC,GRAV,THO,DEP,DEP2)
    ALLOCATE(LN2(NELM2,2),NODE2(NNODE2,2),PHI2(NNODE2),NODE2_TEMP(NNODE2,2))
    ALLOCATE(EQM(NDOFTLD),EQC(NDOFTLD),EQK(NDOFTLD),EQH(NDOFTLD))
    ALLOCATE(M_ALL1(NDOFTLD+1,NDOFTLD+1),C_ALL1(NDOFTLD+1,NDOFTLD+1),K_ALL1(NDOFTLD+1,NDOFTLD+1),K_EFF1(NDOFTLD+1,NDOFTLD+1))
    ALLOCATE(EQZ0(NDOFTLD),EQZ1(NDOFTLD),EQZ2(NDOFTLD),EQZ0_PC(NDOFTLD),EQZ1_PC(NDOFTLD),EQZ2_PC(NDOFTLD),X0_IC(NDOFTLD+1))
    ALLOCATE(B1(NDOFTLD+1),B2(NDOFTLD+1))
    ALLOCATE(M_ALL2(NDOFTLD,NDOFTLD),C_ALL2(NDOFTLD,NDOFTLD),K_ALL2(NDOFTLD,NDOFTLD),K_EFF2(NDOFTLD,NDOFTLD))
    ALLOCATE(XN0(NDOFTLD),XN1(NDOFTLD),XN2(NDOFTLD))
    ALLOCATE(B3(NDOFTLD),B4(NDOFTLD))
    LN2=0
    NODE2=0.D0
    PHI2=0.D0
    NODE2_TEMP=0.D0
    EQM=0.D0
    EQC=0.D0
    EQK=0.D0
    EQH=0.D0
    M_ALL1=0.D0
    C_ALL1=0.D0
    K_ALL1=0.D0
    K_EFF1=0.D0
    EQZ0=0.D0
    EQZ1=0.D0
    EQZ2=0.D0
    EQZ0_PC=0.D0
    EQZ1_PC=0.D0
    EQZ2_PC=0.D0
    X0_IC=0.D0    
    B1=0.D0
    B2=0.D0
    M_ALL2=0.D0
    C_ALL2=0.D0
    K_ALL2=0.D0
    K_EFF2=0.D0
    XN0=0.D0
    XN1=0.D0
    XN2=0.D0
    B3=0.D0
    B4=0.D0

!---CALCULATE EQUIVALENT PARAMETERS (BUT ONLY USED IF MECHANICAL MODEL IS APPLIED)
!    CALL MECH_MODEL_SYS_COUPLED(PI,NDOFTLD,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,&
!                      &EQM,EQC,EQK,EQH,M_ALL1,C_ALL1,K_ALL1,A,K_EFF1,B1,B2)
    CALL MECH_MODEL_SYS_UNCOUPLED(PI,NDOFTLD,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,&
                                 &EQM,EQC,EQK,EQH,M_ALL2,C_ALL2,K_ALL2,A,K_EFF2,B3,B4)
    
!---GAUSDSIN QUADRATURES AND SHAPE FUNCTION
    CALL GAUSS(WT,RT,NGA)
    CALL SHAP(SHA1,SHA2,SH,NGA,RT)

!---SET RMSE OF PHIT TO AVOID CODE STUCK
    E1_1=0.D0
    E1_2=0.D0
    
!---INITIALIZE BODY'S DISPLACEMENT
    Z0(1:2)=G_COOR+R0_IC(1:2)
    Z0(3)=R0_IC(3)
    Z0_IC=Z0
    
!---WAVE TYPE: 1 = PERIODIC WAVE, 2 = SOLITARY WAVE (HALF-SINE IN A SHORT TIME)
	SELECT CASE (WAVTYP1)
	CASE(1)
		DO I=1,NTIM
		 TIME=(I-1)*DELTTIME
		 DI1(I)=AMP1*DSIN(OMEGA1*TIME+PSI1)
		 VE1(I)=AMP1*OMEGA1*DCOS(OMEGA1*TIME+PSI1)
		 AC1(I)=-AMP1*OMEGA1**2*DSIN(OMEGA1*TIME+PSI1)
		 END DO
	CASE(2)
		NT=OMEGA1/DELTTIME
		DO I=1,NT+1
		 TIME=(I-1)*DELTTIME
		 DI1(I)=0.5D0*AMP1-0.5D0*AMP1*DCOS(PI/OMEGA1*TIME)
		 VE1(I)=PI/OMEGA1*0.5*AMP1*DSIN(PI/OMEGA1*TIME)
		 AC1(I)=(PI/OMEGA1)**2*0.5D0*AMP1*DCOS(PI/OMEGA1*TIME)
		END DO
		 DI1(NT+2:NTIM)=DI1(NT+1)
    END SELECT

    SELECT CASE (WAVTYP2)
	CASE(1)
		DO I=1,NTIM
		 TIME=(I-1)*DELTTIME
		 DI2(I)=AMP2*DSIN(OMEGA2*TIME+PSI2)
		 VE2(I)=AMP2*OMEGA2*DCOS(OMEGA2*TIME+PSI2)
		 AC2(I)=-AMP2*OMEGA2**2*DSIN(OMEGA2*TIME+PSI2)
		 END DO
	CASE(2)
		NT=OMEGA2/DELTTIME
		DO I=1,NT+1
		 TIME=(I-1)*DELTTIME
		 DI2(I)=0.5D0*AMP2-0.5D0*AMP2*DCOS(PI/OMEGA2*TIME)
		 VE2(I)=PI/OMEGA2*0.5*AMP2*DSIN(PI/OMEGA2*TIME)
		 AC2(I)=(PI/OMEGA2)**2*0.5D0*AMP2*DCOS(PI/OMEGA2*TIME)
		END DO
		 DI2(NT+2:NTIM)=DI1(NT+1)
    END SELECT
    
!---INITIALIZE WAVE FLOW PATTERN
	CALL LENGTH(NPL,COOR,SIDE_L)
	CALL MESH(NPL,NNODE,NELM,NELEM,LN,COOR,SIDE_L,NODE,Z0,CLV,CRV,BLX,BLY)
    CALL PRESSURE(ICON,THO,GRAV,DEP,NPL,NFL,NNODE,NS,NODE,PHIT,DP,PR,P_ATM)
    CALL KERNEL(KER1,KER2,NODE,NORM,JCB,LENG,LN,NNODE,NELM,NGA,SHA1,SHA2,SH,WT,EYE) ! CALL BCZ NEED JCB
    CALL FORCE_WAVE(TIME,GRAV,MB,NPL,NFL,NNODE,NELM,ME,LN,NODE,NORM,JCB,PR,Z0,FOR)
    FOR_TEMP=FOR
!    DO I=1,2
!        Z2(I)=FOR(I)/MB
!    END DO
!    Z2(3)=FOR(3)/IB
    CALL INITIAL_PE01(NPL,NFL,NNODE,NS,NODE,THO,GRAV,MB,Z0,PE_I0,PE_I1)
    WRITE(20,*) 'PASS WAVE INITIALIZATION'
    
!---INITIALIZE PMTLD FLOW PATTERN
    IF (TLD_YN==1)THEN
	    CALL MESH_TLD(NNODE2,NELM2,NELEM2,ME2,NS2,LN2,TL,TH,TLDLOC,BLX,BLY,COOR2,NODE2,Z0)
        CALL INITIAL_PE2(NNODE2,NODE2,NS2,TMW,THO,GRAV,PE_I2)
        CALL PMTLD_BEM(NNODE2,NELM2,NGA,ICON2,NELEM2,ME2,NS2,LN2,BUNTYP2,MU1,MU2,POR,&
            &GRAV,MU,THO,DELTTIME,TL,TH,TMW,DEP2,TLDLOC,COOR2,Z0,Z1,Z2,WT,SHA1,SHA2,SH,&
            &NODE2,PHI2,NODE2_TEMP,FOR2,KE2,PE2,TE2,WORK2,PE_I2,DTDT2,DVDT2,DEDT2,DWDT2,&
            &WG1_TLD,WG2_TLD,LDP1,LDP2,LDPH1,LDPH2)
        NODE2_TEMP=NODE2        
        WRITE(20,*) 'PASS PMTLD INITIALIZATION'
    ELSE IF (TLD_YN==2)THEN
        EQZ0=Z0(1)
        EQZ0_PC=EQZ0
        X0_IC(1)=Z0(1)
        X0_IC(2:NDOFTLD+1)=EQZ0
        FOR2=0.D0
        PE_I2=TMW*GRAV*Z0(2)
        WRITE(20,*) 'PASS EQUIVALENT PMTLD INITIALIZATION'
    ELSE
        FOR2=0.D0
        WRITE(20,*) 'NO PMTLD INVOLVED'
    END IF
    
!---OUTPUT INITIAL STATE STRUCTURE
    WRITE(31,*) 'body dimensions = ',BLX,'x',BLY,'m'
    WRITE(31,*) 'body density = ',THOB,'kg/m^3'
    WRITE(31,*) 'body mass = ',MB,'kg'
    WRITE(31,*) 'body moment of inertia = ',IB,'kg-m^2'
    WRITE(31,*) 'tank dimensions = ',TL,'x',TH,'m'
    WRITE(31,*) 'fixed mass (kg), fixed inertia (kg-m^2), height (m)'
    WRITE(31,*) MFIX,IFIX,HFIX
    WRITE(31,*) 'moving mass (kg), frequencies (rad/s), damping ratios, height (m)'
    DO I=1,NDOFTLD
        WRITE(31,"(I2,4(1X,F15.6))") I,EQM(I),DSQRT(EQK(I)/EQM(I)),0.5D0*EQC(I)/DSQRT(EQK(I)*EQM(I)),EQH(I)
    END DO

!---OUTPUT INITIAL STATE OF WATER
    DO I=1,NNODE
    WRITE(32,"(I15,4(F15.8,2X))") I,NODE(I,:)
    END DO
    DO I=1,NNODE2
    WRITE(32,"(I15,4(F15.8,2X))") I,NODE2(I,:)
    END DO

!---WALL TIME FOR INITIALIZATION
!      CALL get_walltime(T_INITIAL)
!      WRITE(20,"(A1,F5.1,A16)") '[',T_INITIAL-T_START,'] INITIALIZATION'
    
!******************************** SIMULATION STARTS ********************************
DO NT=1,NTIM
    WRITE(*,*) NT,'TH'
    WRITE(20,*) NT,'TH'
    TIME=(NT-1)*DELTTIME
!---GET STEP CONSUMED WALL TIME
!    CALL get_walltime(T_STEP)
!    WRITE(20,"(A1,F5.1,A1,I6,A2)") '[',T_STEP-T_START,']',NT,'TH'
    
!---WAVEMAKER DIS, VEL, ACC, PHASE LAG (IN RADIUS)
    DIS1=DI1(NT)
    VEL1=VE1(NT)
    ACC1=AC1(NT)
    DIS2=DI2(NT)
    VEL2=VE2(NT)
    ACC2=AC2(NT)
    
!---CALCULATE WAVE SPEED FOR RIGHT SEIDE
    D_OUT=NODE(NS(NFL+2),2)-NODE(NS(NPL-NBT-1),2)
    CALL WAVE_SPD(GRAV,OMEGA1,D_OUT,WC2)
    
!---CALCULATE WAVE SPEED FOR LEFT SEIDE
    D_OUT=NODE(NNODE,2)-NODE(NS(NPL-1),2)
    CALL WAVE_SPD(GRAV,OMEGA2,D_OUT,WC1)

!************** WAVE AND BODY PROBLEM ******************        
!---INITIAL STATE (ACC/FOR AND NODE AND PHI) AT Kth TIME STEP
    FOR_PC=FOR
    Z0_PC=Z0
    Z1_PC=Z1
    Z2_PC=Z2
    NODE_PC=NODE
    NODE_TEMP=NODE
    PHI_PC=PHI
    EQZ0=EQZ0_PC
    EQZ1=EQZ1_PC
    EQZ2=EQZ2_PC
        
DO ITR=1,NITER

!---STORE THE ACC AND FOR OF THE KTH ITERATION TO COMPARE WITH (K+1)TH SOLUTION
    Z2_TEMP=Z2_PC
    FOR_TEMP=FOR_PC
    PHIT_TEMP=PHIT
    
!---BUILD KERNEL
    CALL KERNEL(KER1,KER2,NODE_PC,NORM,JCB,LENG,LN,NNODE,NELM,NGA,SHA1,SHA2,SH,WT,EYE)

!---IMPLICIT SOLVER FOR CONVERGENCE OF PHIT ON RADIATION OUTLET
!DO ITR=1,NITER

!---APPLY BC, SOLVING FREE-SURFACE PPHI, GET FIRST-ORDER TAYLOR SERIES EXPANSION
    CALL BOUND(DORTYP1,DORTYP2,NDOF,NPL,NFL,NNODE,NELM,NELEM,ME,NS,LN,BUNTYP,NODE_PC,NORM,&
              &PHI_PC,PPHI,PHIT,VEL1,VEL2,Z0_PC,Z1_PC,WC1,WC2)
!   CALL SOLVE_BACK(NPL,PHI_PC,PPHI,KER1,KER2,NNODE,NELEM,BUNTYP)        
    CALL SOLVE_LAPACK(NPL,PHI_PC,PPHI,KER1,KER2,NNODE,NELEM,BUNTYP)
!   CALL SOLVE_LAPACK2_1(NPL,PHI_PC,PPHI,KER1,KER2,G1,H1,NNODE,NELEM,BUNTYP)
    CALL TAYES1(NPL,NFL,NBT,NNODE,NELM,ME,NS,LN,NODE_PC,NORM,JCB,PHI_PC,PPHI,&
               &DPDS,DP,PHIT,DPDT,DEP,GRAV,MU,VEL1,VEL2)

!---APPLY BC, SOLVING FREE-SURFACE PPHIT
    CALL ACCBC_KO(NPL,NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI_PC,PPHI,DP,ACCMO)    
!   CALL ACCBC_TSAO(NPL,NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI,PPHI,DP,ACCMO)
!   CALL ACCBC_GRILLI(NPL,NFL,NNODE,NELM,ME,LN,NODE_PC,NORM,JCB,PHI_PC,PPHI,Z0_PC,Z1_PC,ACCMO)        
!   CALL ACCBC_GUERBER(NPL,NFL,NNODE,NELM,ME,LN,NODE_PC,NORM,JCB,PHI_PC,PPHI,Z0_PC,Z1_PC,ACCMO)
!   CALL ACCBC_CAO(NPL,NFL,NNODE,NELM,ME,LN,NODE_PC,NORM,JCB,PHI_PC,PPHI,Z0_PC,Z1_PC,ACCMO)        
    CALL BOUNDT(DORTYP1,DORTYP2,NDOF,NPL,NFL,NNODE,NELM,NELEM,ME,NS,LN,BUNTYP,NODE_PC,NORM,&
               &PHIT,PPHIT,DPDS,JCB,ACC1,ACC2,ACCMO,Z0_PC,Z1_PC,Z2_PC,WC1,WC2)
!   CALL SOLVE_BACK(NPL,PHIT,PPHIT,KER1,KER2,NNODE,NELEM,BUNTYP)        
    CALL SOLVE_LAPACK(NPL,PHIT,PPHIT,KER1,KER2,NNODE,NELEM,BUNTYP)
!   CALL SOLVE_LAPACK2_2(NPL,PHIT,PPHIT,G1,H1,NNODE,NELEM,BUNTYP)

!END DO
!**************************************************************************************

!205 CONTINUE        

!---CALCULATE PRESSURE AND FORCE/MOMENTON ON ALL  BOUNDARIES (SOLID + FREE SURFACE)
    CALL PRESSURE(ICON,THO,GRAV,DEP,NPL,NFL,NNODE,NS,NODE_PC,PHIT,DP,PR,P_ATM)
    CALL FORCE_WAVE(TIME,GRAV,MB,NPL,NFL,NNODE,NELM,ME,LN,NODE_PC,NORM,JCB,PR,Z0_PC,FOR_PC)

!************** CORRECT FOR_PC ******************    
    FOR_PC=FOR_PC+PC*(FOR_TEMP-FOR_PC) ! V1 converged version looks normal
!    FOR_PC=FOR_PC+PC*(FOR_PC-FOR_TEMP) ! V2 peter seems converge faster
!    FOR_PC=FOR_TEMP+PC*(FOR-FOR_TEMP)  ! NG, CHECK Grilli
           
!************** FLOATING BODY DYNAMICS ******************
!    IF (TLD_YN==2)THEN
!        CALL STR_EQTLD(IDOF,GAMMA,BETA,GRAV,A,NDOF,NDOFTLD,DELTTIME,MB,IB,TMW,MFIX,HFIX,IFIX,EQM,EQC,EQK,&
!                      &M_ALL1,C_ALL1,K_ALL1,EQH,K_EFF1,B1,B2,FOR_PC,Z0,Z1,Z2,Z0_PC,Z1_PC,Z2_PC,&
!                      &EQZ0,EQZ1,EQZ2,EQZ0_PC,EQZ1_PC,EQZ2_PC,X0_IC,FOR2)
!    ELSE
        CALL STR(IDOF,GAMMA,BETA,NDOF,DELTTIME,MB,IB,FOR2,FOR_PC,Z0,Z1,Z2,Z0_PC,Z1_PC,Z2_PC)
!    END IF


!---GET SECOND-ORDER TAYLOR SERIES EXPANSION
    CALL TAYES2(NPL,NFL,NNODE,NELM,NS,ME,LN,NODE_PC,NORM,JCB,PHI_PC,PPHI,PHIT,PPHIT,&
                &DP,DPDS,DPDT,D2PDT,D2P,DELTTIME,GRAV,ACC1,ACC2,Z2_PC)

!---REMESH LOCATION AND POTENTIAL OF FREE-SURFACE NODES
    CALL REMESH(NDOF,NPL,NFL,NBT,NELM,NNODE,NELEM,ME,NS,NODE,NODE_PC,DP,D2P,PHI,PHI_PC,DPDT,D2PDT,NORM,&
                &DELTTIME,CLV,CRV,Z0,RBC,COG)
    
!---CALCULATE RMSE FOR RADIATION CONVERGENCE IF INLET OR OUTLET ARE SET AS ABSORPTION
    IF (DORTYP1==3)THEN
        CALL RMSE(NELEM(NPL)+1,PHIT_TEMP(NS(NPL-1)+1:NNODE),PHIT(NS(NPL-1)+1:NNODE),E1_1)    
    ELSE IF (DORTYP2==3)THEN
        CALL RMSE(NELEM(NFL+3)+1,PHIT_TEMP(NS(NFL+2)+1:NS(NFL+3)),PHIT(NS(NFL+2)+1:NS(NFL+3)),E1_2)
    END IF
    E1=MAXVAL([E1_1,E1_2])
    
!---CALCULATE ABSE MAXIMUM FOR FSI CONVERGENCE
    SELECT CASE(CTYPE)
        CASE (1)
            EA=DABS(Z2_PC-Z2_TEMP)
            E2=MAXVAL(EA)
        CASE (2)
            EA=DABS(FOR_PC-FOR_TEMP)
            E2=MAXVAL(EA)
    END SELECT

    IF(E1<=E1TOL.AND.E2<=E2TOL)THEN
        IF (DORTYP1==3.OR.DORTYP2==3)THEN
            WRITE(*,*) 'PASS FSI & RADIATION',ITR,'ITR'
            WRITE(20,*) 'PASS FSI & RADIATION',ITR,'ITR'
        ELSE
            WRITE(*,*) 'PASS FSI',ITR,'ITR'
            WRITE(20,*) 'PASS FSI',ITR,'ITR'
        END IF
        WRITE(21,"(F9.5,I5,2(E15.8,1X))") TIME,ITR,E1,E2
        FOR=FOR_PC
        Z0=Z0_PC
        Z1=Z1_PC
        Z2=Z2_PC
        NODE=NODE_PC
        PHI=PHI_PC
        EQZ0=EQZ0_PC
        EQZ1=EQZ1_PC
        EQZ2=EQZ2_PC
        GOTO 215        
    ELSE IF(ITR>=NITER)THEN
        IF (E1>E1TOL)THEN
            WRITE(*,*) 'RADIATION FAIL'
            WRITE(20,*) 'RADIATION FAIL'
        ELSE IF (E2>E2TOL)THEN
            WRITE(*,*) 'FSI FAIL'
            WRITE(20,*) 'FSI FAIL'
        END IF
        WRITE(21,"(F9.5,I5,2(E15.8,1X))") TIME,ITR,E1,E2
        STOP
    END IF    
        
END DO
215 CONTINUE
        
    
!---CALCULATE FORCE AND MOMENT FROM PMTLD IF PMTLD IS INVOLVED (THIS DOES NOT COUPLED WITH WAVE-BODY INTERACTION)
IF (TLD_YN==1)THEN
    NODE2_TEMP=NODE2
    CALL PMTLD_BEM(NNODE2,NELM2,NGA,ICON2,NELEM2,ME2,NS2,LN2,BUNTYP2,MU1,MU2,POR,&
              &GRAV,MU,THO,DELTTIME,TL,TH,TMW,DEP2,TLDLOC,COOR2,Z0,Z1,Z2,WT,SHA1,SHA2,SH,&
              &NODE2,PHI2,NODE2_TEMP,FOR2,KE2,PE2,TE2,WORK2,PE_I2,DTDT2,DVDT2,DEDT2,DWDT2,&
              &WG1_TLD,WG2_TLD,LDP1,LDP2,LDPH1,LDPH2)
    WRITE(*,*) 'PASS PMTLD BY BEM'
    WRITE(20,*) 'PASS PMTLD BY BEM'
ELSE IF (TLD_YN==2)THEN
    CALL PMTLD_MECHANICAL(PI,TL,TH,NDOFTLD,GRAV,A,TMW,MFIX,IFIX,HFIX,EQM,EQC,EQK,EQH,&
                        &M_ALL2,C_ALL2,K_ALL2,K_EFF2,B3,B4,Z0,Z1,Z2,Z0_IC,XN0,XN1,XN2,FOR2,&
                        &KE2,PE2,TE2,WORK2,PE_I2,DTDT2,DVDT2,DEDT2,DWDT2,WG1_TLD,WG2_TLD)
    WRITE(*,*) 'PASS PMTLD BY MECH.'
    WRITE(20,*) 'PASS PMTLD BY MECH.'
END IF


!--- CALCULATE ENERGY CHANGE OF WAVE AND BODY
CALL ENERGY_WAVE(DORTYP1,DORTYP2,NPL,NFL,NNODE,ME,NELM,LN,NGA,NODE,NODE_TEMP,PHI,PPHI,PHIT,PPHIT,DP,PR,&
                &NORM,JCB,WT,SH,SHA1,SHA2,GRAV,THO,KE0,PE0,TE0,WORK0,PE_I0,DTDT0,DVDT0,DEDT0,DWDT0)

CALL ENERGY_BODY(NPL,NFL,NNODE,ME,NELM,LN,NODE,NODE_TEMP,PPHI,PR,NORM,&
                &GRAV,MB,IB,Z0,Z1,Z2,KE1,PE1,TE1,WORK1,PE_I1,DTDT1,DVDT1,DEDT1,DWDT1)

!---CALCULATE WAVE ELEVATIONS AT GAUGES ALONG WAVE CHANNEL
DO I=1,NWG
    CALL BWLOC(-WGX(I),NS(NFL+2),-NODE(1:NS(NFL+2),1),0,IR,IL)
    WGY(I)=NODE(IL,2)+(WGX(I)-NODE(IL,1))/(NODE(IR,1)-NODE(IL,1))*(NODE(IR,2)-NODE(IL,2))-DEP
END DO

!---CHECK IF UNREASONABLY LARGE SOLUTION OCCUR (STOP IF YES)
    CALL STABLE(TIME,NNODE,NODE,NNODE2,NODE2)
    
!****************************** OUTPUT ******************************
WRITE(5,"(7(E15.8,1X))") TIME,DIS1,VEL1,ACC1,DIS2,VEL2,ACC2
WRITE(61,"(5000(E15.8,1X))") NODE(:,1)
WRITE(61,"(5000(E15.8,1X))") NODE(:,2)
WRITE(62,"(1000(E15.8,1X))") NODE2(:,1) 
WRITE(62,"(1000(E15.8,1X))") NODE2(:,2)
WRITE(9,"(10(E15.8,1X))") TIME,FOR(1),FOR(2)+MB*GRAV,FOR(3),FOR2,FOR+FOR2
WRITE(10,"(10(E15.8,1X))") TIME,Z0(1)-G_COOR(1),Z0(2)-G_COOR(2),Z0(3),Z1,Z2
WRITE(11,"(6(E15.8,1X))") RBC(:,1),COG(1)
WRITE(11,"(6(E15.8,1X))") RBC(:,2),COG(2)
WRITE(13,"(13(E15.8,1X))") TIME,KE0,PE0,TE0,WORK0,KE1,PE1,TE1,WORK1,KE2,PE2,TE2,WORK2
WRITE(14,"(13(E15.8,1X))") TIME,DTDT0,DVDT0,DEDT0,DWDT0,DTDT1,DVDT1,DEDT1,DWDT1,DTDT2,DVDT2,DEDT2,DWDT2
WRITE(71,"(11(E15.8,1X))") TIME,WGY(1:NWG)*100.D0
WRITE(72,"(3(E15.8,1X))") TIME,WG1_TLD*100.D0,WG2_TLD*100.D0
WRITE(81,"(5(E15.8,1X))") TIME,LDP1,LDP2,LDPH1,LDPH2
!****************************** OUTPUT ******************************

END DO

!---GET PROGRAM CONSUMED WALL TIME
!    CALL get_walltime(T_END)
!    WRITE(20,"(A1,F5.1,A13)") '[',T_END-T_START,'] PROGRAM END'

STOP
END
!******************** END OF THE PROGRAM *************** 
!---CHECK THE CFL NUMBER	
!	  CALL COURANT(TIME,DELTTIME,NNODE,NELM,LN,NODE,DP,JCB)!++++

!---CALCULATE PRESSURE AND VELOCITY IN THE DOMAIN
!	  CALL DOMAIN(NPL,NGA,NFIELD,NNODE,NELM,NELEM,NS,LN,NODE,NORM,JCB,PHI,PPHI,PHIT,PPHIT,SHA1,SHA2,SH,WT,THO,GRAV,DEP,P_ATM,DP,PR) !++++++++++++++++++++++++++++++++++++++++++++++++

!**********************************************************************
      SUBROUTINE HEADLINE(ID,IREAD)
!**********************************************************************
      CHARACTER*2 ID
      ID =  '*'
      DO WHILE (ID .EQ. '*')
      READ(IREAD,'(A1)') ID
      END DO
      RETURN
      END
!**********************************************************************
      SUBROUTINE INPUT_1(NPL,NFL,COOR,NFIELD,NNODE,NELM,NELEM,ME,NS,BUNTYP,NGA,&
                      &GRAV,MU,WIDTH,THO,NTIM,DELTTIME,GAMMA,BETA,PC,ICON,&
                      &NITER,E1TOL,E2TOL,CTYPE,DEP,BLX,BLY,G_COOR,CLV,CRV)
!**********************************************************************
      IMPLICIT NONE
	  INTEGER I,J,NPL,NFL,NFIELD,NNODE,NELM,NGA,NTIM,ICON,NITER,CTYPE
	  INTEGER NELEM(NPL),ME(NPL),NS(NPL),BUNTYP(NPL)
	  REAL*8 ENDTIME,DELTTIME,GRAV,MU,WIDTH,THO,E1TOL,E2TOL
      REAL*8 DEP,BLX,BLY,GAMMA,BETA,PC,ET
      REAL*8 COOR(NPL,2),G_COOR(2),CLV(2),CRV(2)
      CHARACTER*2 ID
      ET=1.E-12
         ID = '*'
!---READ VERTEX NODE COORDINATES
         CALL HEADLINE(ID,1)
         READ(1,*)  ((COOR(I,J),J=1,2),I=1,NPL)
!---GIVE WATER DEPTH
         DEP=COOR(NPL,2)
!---READ ELEMENT MESH NUMBER
        CALL HEADLINE(ID,1)
        READ(1,*) (NELEM(I),I=1,NPL)
!---CALCULATE NUMBERS OF TOTAL NODE, TOTAL ELEMENT, ACCUMULATE NODE ON PLANE, ACCUMULATE ELEMENT ON PLANE
        NNODE=0
        NELM=0
        DO I=1,NPL
          NELM = NELM+NELEM(I)
          NNODE = NNODE+(NELEM(I)+1)
        END DO
		ME(1)=NELEM(1)
        NS(1)=NELEM(1)+1        
		DO I=2,NPL
		  ME(I)=ME(I-1)+NELEM(I)
          NS(I)=NS(I-1)+NELEM(I)+1          
		END DO
!---CALCULATE NUMBER OF NODE IN DOMAIN
	   NFIELD=(NELEM(1)-1)*(NELEM(2)-1)
!---DEFINE NODE INDEX FOR BERNOULLI CONSTANT
        IF(MOD(NS(1),2)==1)THEN
          ICON=(NS(1)+1)/2
        ELSE
          ICON=NS(1)/2
        END IF
!---BOUNDARY TYPE
         CALL HEADLINE(ID,1)
         READ(1,*) (BUNTYP(I),I=1,NPL)
!---READ THE GAUSSIAN INTEGRATION POINT NO.
         CALL HEADLINE(ID,1)
         READ(1,*)  NGA
!---READ gravity, mu, channel width, tho
         CALL HEADLINE(ID,1)
         READ(1,*)  GRAV,MU,WIDTH,THO
!---READ endtime, delttime, niter, e1tol, e2tol, converge type
         CALL HEADLINE(ID,1)
         READ(1,*)  ENDTIME,DELTTIME,NITER,E1TOL,E2TOL,CTYPE
!---GIVE NUMBER OF TIME STEP
		 NTIM=ENDTIME/DELTTIME+1
!---READ gamma beta of Newmark method, coefficient of predictor
         CALL HEADLINE(ID,1)
         READ(1,*) GAMMA,BETA,PC
!---CHECK GEOMETRY CONFLICT        
     IF (DABS(BLX-DABS(COOR(NPL-1,1)-COOR(NPL-NFL-1,1)))>=ET)THEN
		WRITE(*,*) "FLOATING BODY LENGTH ERR"
        WRITE(20,*) "FLOATING BODY LENGTH ERR"
        STOP
     ELSE IF (BLY<DABS(COOR(NPL-1,2)-COOR(NPL-2,2)))THEN
        WRITE(*,*) "FLOATING BODY TOO SHORT"
        WRITE(20,*) "FLOATING BODY TOO SHORT"
        STOP
     END IF
!---CALCULATE COG COORDINATE
    G_COOR(1)=COOR(NPL-2,1)+0.5D0*BLX
    G_COOR(2)=COOR(NPL-2,2)+0.5D0*BLY
!---CALCULATE VECTOR OF CORNER-COG 
    CRV=COOR(NPL-3,:)-G_COOR
    CLV=COOR(NPL-2,:)-G_COOR

    RETURN
    END
!**********************************************************************
      SUBROUTINE INPUT_2(NPL,NFL,NBT,DORTYP1,DORTYP2,WAVTYP1,WAVTYP2,AMP1,OMEGA1,PSI1,AMP2,OMEGA2,PSI2,&
                        &NWG,WGX,NDOF,BLX,BLY,THOB,MB,IB,R0_IC,IDOF)
!**********************************************************************
      IMPLICIT NONE
	  INTEGER NPL,NFL,NBT,NWG,NDOF,DORTYP1,DORTYP2,WAVTYP1,WAVTYP2,IDOF(3)
      REAL*8 AMP1,OMEGA1,PSI1,AMP2,OMEGA2,PSI2
	  REAL*8 BLX,BLY,THOB,MB,IB,WGX(10),R0_IC(3)
      CHARACTER*2 ID
      ID = '*'
!---NUMBER OF PLANES
         CALL HEADLINE(ID,2)
         READ(2,*) NPL,NFL,NBT
!---WHAT KIND OF BOUNDARY IS LEFT AND RIGHT: 0 = WALL; 1 = PISTON WAVEMAKER; 2 = FLAP WAVEMAKER; 3=RADIATION
         CALL HEADLINE(ID,2)
         READ(2,*) DORTYP1,DORTYP2
!---WHAT KIND OF WAVE: 1 = PERIODIC; 2 = SOLITARY
         CALL HEADLINE(ID,2)
         READ(2,*) WAVTYP1,WAVTYP2
!---READ wavemaker parameters
         CALL HEADLINE(ID,2)
         READ(2,*)  AMP1,OMEGA1,PSI1,AMP2,OMEGA2,PSI2
!---WAVE GENERATION: 1=PERIODIC; 2=SOLITARY
         CALL HEADLINE(ID,2)
         READ(2,*) NWG
!---CHECK WAVE GAUGE ALLOCATION
		 IF (NWG>10)THEN
		 WRITE(*,*) "NEED MORE ALLOCATION FOR WAVE GAUGE"
		 WRITE(20,*) "NEED MORE ALLOCATION FOR WAVE GAUGE"
		 STOP
         END IF
!---READ WAVE GAUGE X-LOCATION
         CALL HEADLINE(ID,2)
         READ(2,*) WGX(1:NWG)
!---NUMBER OF MASS OF THE FLOATING BODY
         CALL HEADLINE(ID,2)
         READ(2,*) NDOF
!---READ LENGTH, HEIGHT, AND DENSITY OF THE FLOATING BODY
         CALL HEADLINE(ID,2)
         READ(2,*) BLX,BLY,THOB
!---CALCULATE THE MASS AND MOMENT OF INERTIA OF THE RECTANGULAR FLOATING BODY
         MB=BLX*BLY*THOB
         IB=MB*(BLX**2+BLY**2)/12.D0
!---INPUT INITIAL DISPLACEMENT (NOTE THE ORIGIN LOACTES ON FREE SURFACE)
         CALL HEADLINE(ID,2)
         READ(2,*) R0_IC(1:3)
         R0_IC(3)=R0_IC(3)*DACOS(-1.D0)/180.D0
!---INPUT DEGREE OF FREEDOM OF THE BODY ALONG 3 DIRECTIONS (1 = MOVABLE ; 0 = FIXED)
         CALL HEADLINE(ID,2)
         READ(2,*) IDOF
         
      RETURN
      END
!**********************************************************************
      SUBROUTINE INPUT_3(TLD_YN,NDOFTLD,COOR,NNODE,NELM,NELEM,ME,NS,BUNTYP,MU1,MU2,POR,ICON,TL,TH,MW,WN,TLDLOC,GRAV,THO,DEP,DEP2)
!**********************************************************************
      IMPLICIT NONE
      INTEGER I,J,IREAD,NNODE,NELM,ICON,TLD_YN,NDOFTLD
      INTEGER NELEM(4),BUNTYP(4),ME(4),NS(4)
      REAL*8 COOR(4,2),DEP,DEP2,MU1,MU2,POR,MW,WN,GRAV,THO,TL,TH,TLDLOC(2)
      CHARACTER*2 ID
      ID = '*'
      IREAD = 3
!---do you have PMTLD?
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) TLD_YN
!---DOF of equivalent PMTLD
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) NDOFTLD
!---input the coordinate of vertex of PMTLD domain
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) ((COOR(I,J),J=1,2),I=1,4)
      TL=COOR(2,1)-COOR(1,1)
      TH=COOR(3,2)-COOR(2,2)
      DEP2=DEP+TH
!--- READ ELEMENT MESH NUMBER
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) (NELEM(I),I=1,4)
!---CALCULATE NUMBERS OF TOTAL NODE, TOTAL ELEMENT, ACCUMULATE NODE ON PLANE, ACCUMULATE ELEMENT ON PLANE
      NNODE = 0
      NELM  = 0
      DO I=1,4
         NELM = NELM+NELEM(I)
         NNODE = NNODE+(NELEM(I)+1)
      END DO
      ME(1) = NELEM(1)
      NS(1) = NELEM(1)+1
      DO I=2,4
        ME(I)=ME(I-1)+NELEM(I)
        NS(I)=NS(I-1)+NELEM(I)+1          
      END DO
!---DEFINE NODE INDEX FOR BERNOULLI CONSTANT
        IF(MOD(NS(1),2)==1)THEN
          ICON=(NS(1)+1)/2
        ELSE
          ICON=NS(1)/2
        END IF      
!---BOUNDARY TYPE
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) (BUNTYP(I),I=1,4)
!---READ linear damping ratio, mu2, porosity
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*)  MU1,MU2,POR
!---CALCULATE NATURAL FREQUENCY AND TRANSFER DAMPING EFFECT COEFFICIENT
      MW=POR*THO*TL*TH
      WN=SQRT(DACOS(-1.D0)*GRAV*TANH(DACOS(-1.D0)*TH/TL)/TL)
      MU1=MU1*2.D0*WN
!---*INPUT THE POSITION OF THE TLD RELATIVE TO COG OF THE BODY
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*) TLDLOC
      
      RETURN
    END
!**********************************************************************
      SUBROUTINE INPUT_4(NDOF,AD,ED,BD)
!**********************************************************************
      IMPLICIT NONE
      INTEGER I,J,IREAD,NDOF
      REAL*8 AD(6*NDOF,6*NDOF),ED(6*NDOF),BD(6*NDOF)
      CHARACTER*2 ID
      ID = '*'
      IREAD = 4
!---input state space matrices for equivalent mechanical PMTLD system
      CALL HEADLINE(ID,IREAD)
      READ(IREAD,*)  ((AD(I,J),J=1,6*NDOF),I=1,6*NDOF)
      READ(IREAD,*)  (ED(I),I=1,6*NDOF)
      READ(IREAD,*)  (BD(I),I=1,6*NDOF)

      RETURN
      END
!**********************************************************************
      SUBROUTINE LENGTH(NPL,COOR1,SIDE_L1)
!**********************************************************************
      IMPLICIT INTEGER (I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
	  INTEGER NPL
      REAL*8  COOR1(NPL,2),SIDE_L1(NPL)
      DO I=1,NPL-1
        SIDE_L1(I)=DSQRT((COOR1(I+1,1)-COOR1(I,1))**2+(COOR1(I+1,2)-COOR1(I,2))**2)
      END DO
        SIDE_L1(NPL)=DSQRT((COOR1(NPL,1)-COOR1(1,1))**2+(COOR1(NPL,2)-COOR1(1,2))**2)

      RETURN
      END
!**********************************************************************
      SUBROUTINE MESH(NPL,NNODE,NELM,NELEM,LN,COOR,LENG,NODE,Z0,CLV,CRV,BLX,BLY)
!********************************************************************
      IMPLICIT INTEGER (I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER NPL,NEL(NPL),NNODE,NELM,NELEM(NPL),LN(NELM,2)
      REAL*8 SX,SY,NORM,DELT,BLX,BLY,LENG(NPL),COOR(NPL,2),NODE(NNODE,2)
      REAL*8 Z0(3),Q(2,2),CLV(2),CRV(2),RL(2),RR(2)

!------SET ROTATIONAL MATRIX
    Q(1,1)=DCOS(Z0(3))
    Q(1,2)=-DSIN(Z0(3))
    Q(2,1)=-Q(1,2)
    Q(2,2)=Q(1,1)
    
!------SET THE CORNER POINTS IN INERTIA FRAME (THIS BODY HAS 2 CORNERS)
    RL=MATMUL(Q,CLV)
    RR=MATMUL(Q,CRV)

    DO I=1,2
    COOR(NPL-2,I)=RL(I)+Z0(I)
    COOR(NPL-3,I)=RR(I)+Z0(I)
    END DO
    
    COOR(NPL-1,1)=Z0(1)-0.5*BLX/DCOS(Z0(3))
    COOR(NPL-4,1)=Z0(1)+0.5*BLX/DCOS(Z0(3))
    
!------MESH
    K=0
    DO I=1,NPL-1
	J=NPL-I
    NEL(I) = NELEM(I)+1
!    DELT=LENG(J)/NELEM(I)   
	SX=COOR(J,1)-COOR(J+1,1)
	SY=COOR(J,2)-COOR(J+1,2)
	NORM=DSQRT(SX**2+SY**2)
    DELT=NORM/NELEM(I)    
	SX=SX/NORM
	SY=SY/NORM
    DO L=1,NELEM(I)+1
       NODE(L+K,1)=COOR(J+1,1)+(L-1)*DELT*SX
       NODE(L+K,2)=COOR(J+1,2)+(L-1)*DELT*SY
    END DO
    K=K+NEL(I)
    END DO

    NEL(NPL) = NELEM(NPL)+1
    DELT=LENG(NPL)/NELEM(NPL)
	SX=COOR(NPL,1)-COOR(1,1)
	SY=COOR(NPL,2)-COOR(1,2)
	NORM=DSQRT(SX**2+SY**2)
	SX=SX/NORM
	SY=SY/NORM
    DO I=1,NELEM(NPL)+1
      NODE(I+K,1)=COOR(1,1)+(I-1)*DELT*SX
      NODE(I+K,2)=COOR(1,2)+(I-1)*DELT*SY
    END DO

!----TO GIVE THE LOCAL ELEMENT NODE NUMBER
      L=1
	  N=1
      DO I=1,NPL
       DO J=1,NELEM(I)
        LN(N,1)=L
        LN(N,2)=L+1
        L=L+1
		N=N+1
       END DO
       L=L+1
      END DO

      RETURN
    END
!**********************************************************************
      SUBROUTINE MESH_TLD(NNODE,NELM,NELEM,ME,NS,LN,TL,TH,TLDLOC,BLX,BLY,COOR,NODE,Z0)
!********************************************************************
      IMPLICIT NONE
      INTEGER I,J,L,N,NNODE,NELM,NELEM(4),ME(4),NS(4),LN(NELM,2)
      REAL*8 TL,TH,BLX,BLY,SX,SY,RL,LL,DELT,COOR(4,2),NODE(NNODE,2),Z0(3),TLDLOC(2),TEMP(2)

!---CHECK WAVE ELEVATION ON SIDE WALLS > 0      
      RL=TH-0.5D0*TL*DTAN(Z0(3))
      LL=TH+0.5D0*TL*DTAN(Z0(3))
      IF (RL<=0.D0.OR.LL<=0.D0)THEN
        WRITE(20,*) 'PMTLD SIDE DEPTH < 0'
        WRITE(*,*) 'PMTLD SIDE DEPTH < 0'
        STOP
      END IF

!------MESH FS
    DELT=TL/DCOS(Z0(3))/NELEM(1) ! FS REMAIN FLAT
    DO I=1,NS(1)
       NODE(I,1)=COOR(4,1)+(I-1)*DELT
       NODE(I,2)=COOR(4,2)
    END DO

!------MESH RIGHT WALL
    DELT=RL/NELEM(2)
    SX=DSIN(Z0(3))
    SY=-DCOS(Z0(3))
    J=1
    DO I=NS(1)+1,NS(2)
       NODE(I,1)=NODE(NS(1),1)+(J-1)*DELT*SX
       NODE(I,2)=NODE(NS(1),2)+(J-1)*DELT*SY
       J=J+1
    END DO

!------MESH BOTTOM
    DELT=TL/NELEM(3)
    SX=-DCOS(Z0(3))
    SY=-DSIN(Z0(3))
    J=1
    DO I=NS(2)+1,NS(3)
       NODE(I,1)=NODE(NS(2),1)+(J-1)*DELT*SX
       NODE(I,2)=NODE(NS(2),2)+(J-1)*DELT*SY
       J=J+1
    END DO   
    
!------MESH LEFT WALL
    DELT=LL/NELEM(4)
    SX=-DSIN(Z0(3))
    SY=DCOS(Z0(3))
    J=1
    DO I=NS(3)+1,NS(4)
       NODE(I,1)=NODE(NS(3),1)+(J-1)*DELT*SX
       NODE(I,2)=NODE(NS(3),2)+(J-1)*DELT*SY
       J=J+1
    END DO
    
!---SET THE TLD ON THE BOX BY LOCATING LEFT-BOTTOM CORNER
    TEMP=NODE(NS(3),:)
    DO I=1,NNODE
        NODE(I,1)=Z0(1)+(TLDLOC(1)-0.5D0*TL)*DCOS(Z0(3))-DSIN(Z0(3))*TLDLOC(2)+NODE(I,1)-TEMP(1)
        NODE(I,2)=Z0(2)+(TLDLOC(1)-0.5D0*TL)*DSIN(Z0(3))+DCOS(Z0(3))*TLDLOC(2)+NODE(I,2)-TEMP(2)
    END DO
    
!----TO GIVE THE LOCAL ELEMENT NODE NUMBER
      L=1
	  N=1
      DO I=1,4
       DO J=1,NELEM(I)
        LN(N,1)=L
        LN(N,2)=L+1
        L=L+1
		N=N+1
       END DO
       L=L+1
      END DO

      RETURN
      END
!********************************************************************
      SUBROUTINE SHAP(SHA1,SHA2,SH,NGA,RT)
!********************************************************************
      IMPLICIT INTEGER (I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER NGA
      REAL*8 RT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)
      DO M=1,NGA
        SHA1(M)=0.5D0*(1-RT(M))
        SHA2(M)=0.5D0*(1+RT(M))

        SH(1,M)=SHA1(M)
        SH(2,M)=SHA2(M)
      END DO
	RETURN
	END 
!**********************************************************************
      SUBROUTINE REMESH(NDOF,NPL,NFL,NBT,NELM,NNODE,NELEM,ME,NS,NODE,NODE_PC,DP,D2P,PHI,PHI_PC,DPDT,D2PDT,NORM,&
                      &DELTTIME,CLV,CRV,Z0,RBC,COG)
!**********************************************************************
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER NDOF,NPL,NFL,NBT,NELM,NNODE,ME(NPL),NELEM(NPL),NS(NPL),NWG,IL,IR
      REAL*8 LENG,SX,SY,SNORM,HEL,HER,HE,DELTTIME,TEMP
      REAL*8 Q(2,2),CLV(2),CRV(2),CL(2),CR(2),RL(2),RR(2),RBC(5,2),COG(2),Z0(3*NDOF)
      REAL*8 NODE(NNODE,2),NODE_PC(NNODE,2),NORM(NELM,2),DP(NNODE,2),D2P(NNODE,2)
      REAL*8 PHI(NNODE),PHI_PC(NNODE),DPDT(NNODE),D2PDT(NNODE)

!-----REMESH FREE SURFACE NODE-----
    DO I=1,NS(1)
	NODE_PC(I,1)=NODE(I,1)+DP(I,1)*DELTTIME+0.5D0*D2P(I,1)*DELTTIME**2
    NODE_PC(I,2)=NODE(I,2)+DP(I,2)*DELTTIME+0.5D0*D2P(I,2)*DELTTIME**2
	PHI_PC(I)=PHI(I)+DELTTIME*DPDT(I)+0.5D0*D2PDT(I)*DELTTIME**2
    END DO

	DO I=NS(NFL+1)+1,NS(NFL+2)
	NODE_PC(I,1)=NODE(I,1)+DP(I,1)*DELTTIME+0.5D0*D2P(I,1)*DELTTIME**2
    NODE_PC(I,2)=NODE(I,2)+DP(I,2)*DELTTIME+0.5D0*D2P(I,2)*DELTTIME**2
	PHI_PC(I)=PHI(I)+DELTTIME*DPDT(I)+0.5D0*D2PDT(I)*DELTTIME**2
	END DO
      
!------ENSURE DUPLICATE POINT ON SIDE END NODE OF FREE SURFACE-----
    NODE_PC(NNODE,:)=NODE_PC(1,:)
	NODE_PC(NS(NFL+2)+1,:)=NODE_PC(NS(NFL+2),:)

!------BOTTOM END NODE GOES WITH FREE SURFACE -----
	NODE_PC(NS(NPL-1),1)=NODE_PC(1,1)
	NODE_PC(NS(NFL+3),1)=NODE_PC(NS(NFL+2),1)

!------SET ROTATIONAL MATRIX
    Q(1,1)=DCOS(Z0(3))
    Q(1,2)=-DSIN(Z0(3))
    Q(2,1)=-Q(1,2)
    Q(2,2)=Q(1,1)

!------SET THE CORNER POINTS IN INERTIA FRAME (THIS BODY HAS 2 CORNERS)
    RL=MATMUL(Q,CLV)
    RR=MATMUL(Q,CRV)
    DO I=1,2
    CL(I)=RL(I)+Z0(I)
    CR(I)=RR(I)+Z0(I)
    
    RBC(1,I)=CL(I)
    RBC(2,I)=CR(I)
    RBC(3,I)=-RL(I)+Z0(I)
    RBC(4,I)=-RR(I)+Z0(I)
    RBC(5,I)=RBC(1,I)    
    END DO

    COG=0.25D0*(RBC(1,:)+RBC(2,:)+RBC(3,:)+RBC(4,:))

!------REMESH FOR FLOATING BODY LEFT SIDE
    I=2 !THE Ith PLANE
	SNORM=DSQRT((CR(1)-CL(1))**2+(CR(2)-CL(2))**2)
	SX=-(CR(2)-CL(2))/SNORM
	SY=(CR(1)-CL(1))/SNORM
    HL=(NODE_PC(NS(I-1),1)-CL(1))*SX+(NODE_PC(NS(I-1),2)-CL(2))*SY
	DELT=HL/NELEM(I)
    K=1
    DO L=NS(I-1)+1,NS(I)
        NODE_PC(L,1)=CL(1)+HL*SX-DELT*(K-1)*SX
        NODE_PC(L,2)=CL(2)+HL*SY-DELT*(K-1)*SY
        K=K+1
    END DO

!---MAKE THE FS NODE STILL ON THE RIGID BODY PLANE
    NODE_PC(NS(I-1),:)=NODE_PC(NS(I-1)+1,:) ! KEEP PHI THE SAME FOR THE NEW LOCATION
    
!---CHECK THE FS NODE BESIDE THE INTERSECTION WENT INTO THE RIGID BODY OR NOT
    TEMP=(NODE_PC(NS(1)-1,1)-NODE_PC(NS(1),1))*NORM(ME(1)+1,1)+&
        &(NODE_PC(NS(1)-1,2)-NODE_PC(NS(1),2))*NORM(ME(1)+1,2)
    IF (TEMP>=0.D0)THEN
        WRITE(20,*) 'WAVE NODE PENETRATE - LEFT'
        WRITE(*,*) 'WAVE NODE PENETRATE - LEFT'
        STOP
    END IF
 
!------REMESH FOR FLOATING BODY BOTTOM
    I=3 !THE Ith PLANE
    SX=CR(1)-CL(1)
	SY=CR(2)-CL(2)
	SNORM=DSQRT(SX**2+SY**2)
	SX=SX/SNORM
	SY=SY/SNORM
	DELT=SNORM/NELEM(I)
    K=1
    DO L=NS(I-1)+1,NS(I)
        NODE_PC(L,1)=CL(1)+DELT*(K-1)*SX
        NODE_PC(L,2)=CL(2)+DELT*(K-1)*SY
        K=K+1
    END DO

!------REMESH FOR FLOATING BODY RIGHT SIDE
    I=4 !THE Ith PLANE
	SNORM=DSQRT((CR(1)-CL(1))**2+(CR(2)-CL(2))**2)
	SX=-(CR(2)-CL(2))/SNORM
	SY=(CR(1)-CL(1))/SNORM
    HR=(NODE_PC(NS(I)+1,1)-CR(1))*SX+(NODE_PC(NS(I)+1,2)-CR(2))*SY
	DELT=HR/NELEM(I)
    K=1
    DO L=NS(I-1)+1,NS(I)
        NODE_PC(L,1)=CR(1)+DELT*(K-1)*SX
        NODE_PC(L,2)=CR(2)+DELT*(K-1)*SY
        K=K+1
    END DO

!---MAKE THE FS NODE STILL ON THE RIGID BODY PLANE
    NODE_PC(NS(I)+1,:)=NODE_PC(NS(I),:) ! KEEP PHI THE SAME FOR THE NEW LOCATION
    
!---CHECK THE FS NODE BESIDE THE INTERSECTION WENT INTO THE RIGID BODY OR NOT
    TEMP=(NODE_PC(NS(1+NFL)+2,1)-NODE_PC(NS(1+NFL)+1,1))*NORM(ME(1+NFL),1)+&
        &(NODE_PC(NS(1+NFL)+2,2)-NODE_PC(NS(1+NFL)+1,2))*NORM(ME(1+NFL),2)
    IF (TEMP>=0.D0)THEN
        WRITE(20,*) 'WAVE NODE PENETRATE - RIGHT'
        WRITE(*,*) 'WAVE NODE PENETRATE - RIGHT'
        STOP
    END IF
    
!------REMESH FOR ALL PLANES EXCEPT FLOATING BODY AND FREE SURFACE
DO I=NFL+3,NPL
	SX=NODE_PC(NS(I),1)-NODE_PC(NS(I-1),1)
	SY=NODE_PC(NS(I),2)-NODE_PC(NS(I-1),2)
	SNORM=DSQRT(SX**2+SY**2)
	SX=SX/SNORM
	SY=SY/SNORM
	DELT=SNORM/NELEM(I)
	  K=1
      DO L=NS(I-1)+1,NS(I)
        NODE_PC(L,1)=NODE_PC(NS(I-1),1)+DELT*(K-1)*SX
        NODE_PC(L,2)=NODE_PC(NS(I-1),2)+DELT*(K-1)*SY
		K=K+1
      END DO
END DO

    RETURN
    END
!********************************************************************
SUBROUTINE BOUND(DORTYP1,DORTYP2,NDOF,NPL,NFL,NNODE,NELM,NELEM,ME,NS,LN,BUNTYP,NODE,NORM,PHI,PPHI,PHIT,VEL1,VEL2,Z0,Z1,WC1,WC2)
!********************************************************************
IMPLICIT NONE
INTEGER I,J,K,N,DORTYP1,DORTYP2,NDOF,NPL,NFL,NELM,NNODE,NELEM(NPL),ME(NPL),NS(NPL),LN(NELM,2),BUNTYP(NPL)
REAL*8 VX,VY,DX,DY,R,VEL1,VEL2,WC1,WC2
REAL*8 NODE(NNODE,2),NORM(NELM,2),PHI(NNODE),PPHI(NNODE),PHIT(NNODE)
REAL*8 Z0(3*NDOF),Z1(3*NDOF)

N=0
DO I=1,NPL ! PLANE NUMBER
    DO J=N+1,ME(I) ! ELEMENT NUMBER
        DO K=1,2   ! LN(J,K) = NODE NUMBER
            IF (BUNTYP(I) .EQ. 1) THEN          ! BC FOR FREE SURFACE
                PHI(LN(J,K))=PHI(LN(J,K))
                PPHI(LN(J,K))=0.D0
            ELSE
                IF (I==(NFL+3))THEN               ! BC FOR RIGHT SIDE
                    IF (DORTYP2==0)THEN
                        PPHI(LN(J,K))=0.D0
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP2==1)THEN
                        PPHI(LN(J,K))=VEL2
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP2==2)THEN
                        PPHI(LN(J,K))=VEL2*DSQRT((NODE(LN(J,K),1)-NODE(NS(NPL-1),1))**2+&
                        &(NODE(LN(J,K),2)-NODE(NS(NPL-1),2))**2)
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP2==3)THEN
                        PPHI(LN(J,K))=-PHIT(LN(J,K))/WC2 !
                        PHI(LN(J,K))=0.D0
                    END IF
                ELSE IF (I==NPL)THEN              ! BC FOR LEFT SIDE
                    IF (DORTYP1==0)THEN
                        PPHI(LN(J,K))=0.D0
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP1==1)THEN
                        PPHI(LN(J,K))=-VEL1
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP1==2)THEN
                        PPHI(LN(J,K))=-VEL1*DSQRT((NODE(LN(J,K),1)-NODE(NS(NPL-1),1))**2+&
                        &(NODE(LN(J,K),2)-NODE(NS(NPL-1),2))**2)
                        PHI(LN(J,K))=0.D0
                    ELSE IF (DORTYP1==3)THEN
                        PPHI(LN(J,K))=-PHIT(LN(J,K))/WC1 !
                        PHI(LN(J,K))=0.D0
                    END IF
                ELSE IF (I>1.AND.I<=(NFL+1))THEN  ! BC FOR RIGID BODY
                    DX=NODE(LN(J,K),1)-Z0(1)
                    DY=NODE(LN(J,K),2)-Z0(2)
                    VX=Z1(1)-Z1(3)*DY
                    VY=Z1(2)+Z1(3)*DX
                    PPHI(LN(J,K))=VX*NORM(J,1)+VY*NORM(J,2)
                    PHI(LN(J,K))=0.D0
                ELSE                              ! BC FOR BOTTOM
                    PPHI(LN(J,K))=0.D0
                    PHI(LN(J,K))=0.D0
                END IF
            END IF
        END DO
    END DO
    N=ME(I)
END DO

RETURN
END
!********************************************************************
      SUBROUTINE KERNEL(KER1,KER2,NODE,NORM,JCB,LENG,LN,NNODE,NELM,NGA,SHA1,SHA2,SH,WT,EYE)
!********************************************************************
      IMPLICIT NONE
      INTEGER I,J,K,L,M,N,NNODE,NELM,NGA,LN(NELM,2)
      REAL*8 RD,SIGMA(NNODE),EYE(NNODE)
      REAL*8  KER1(NNODE,NNODE),KER2(NNODE,NNODE)
      REAL*8  NX,NY,H(2),G(2),XFUNC(10),YFUNC(10),PXI1(2)
      REAL*8  LENG(NELM),NORM(NELM,2),JCB(NELM),NODE(NNODE,2)
      REAL*8  WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)

        KER1=0.D0
        KER2=0.D0
!**** CALCULATE THE JACOBIAN
      DO J=1,NELM
      LENG(J)=DSQRT((NODE(LN(J,1),1)-NODE(LN(J,2),1))**2+(NODE(LN(J,1),2)-NODE(LN(J,2),2))**2)
		DO L=1,2
          PXI1(L)=(-0.5D0)*NODE(LN(J,1),L)+ 0.5D0*NODE(LN(J,2),L)
        END DO
        NX=PXI1(2)
        NY=PXI1(1)
        JCB(J)=DSQRT(NX**2+NY**2)
        NORM(J,1)=-NX/JCB(J)
        NORM(J,2)=NY/JCB(J)
      END DO
      
!$omp parallel do private(I,J,K,M,XFUNC,YFUNC,RD,G,H)
!***THE SURFACE KERNELS
      DO I = 1,NNODE
       DO J=1,NELM
       DO M=1,NGA
          XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
          YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
       END DO
        DO K=1,2
         G(K)=0.D0
         H(K)=0.D0
         RD=DSQRT((NODE(I,1)-NODE(LN(J,K),1))**2+(NODE(I,2)-NODE(LN(J,K),2))**2)
        IF (RD .LE. 0.000001D0) THEN
        H(K)=0.D0
	    G(K)=LENG(J)/2*(1.5D0-DLOG(LENG(J)))
		ELSE !---NON DSINGULER TERM
         G(K)=0.D0
         DO M=1,NGA
            H(K)=H(K)+(-1.D0)/((XFUNC(M)-NODE(I,1))**2+(YFUNC(M)-NODE(I,2))**2)*&
                    &((XFUNC(M)-NODE(I,1))*NORM(J,1)+(YFUNC(M)-NODE(I,2))*NORM(J,2))&
                    &*JCB(J)*SH(K,M)*WT(M)
            G(K)=G(K)+DLOG(1.D0/((XFUNC(M)-NODE(I,1))**2+(YFUNC(M)-NODE(I,2))**2)**0.5D0)*JCB(J)*SH(K,M)*WT(M)
         END DO
      END IF
         KER1(I,LN(J,K))=KER1(I,LN(J,K))+H(K)
         KER2(I,LN(J,K))=KER2(I,LN(J,K))+G(K)
      END DO
      END DO
      END DO
!$omp end parallel do
      
!***DSINGULAR OF KER1
    DO I=1,NNODE
    KER1(I,I)=0.D0
    END DO      
      CALL DGEMM('N','N',NNODE,1,NNODE,1.D0,KER1,NNODE,EYE,NNODE,0.D0,SIGMA,NNODE)
    DO I=1,NNODE
    KER1(I,I)=-SIGMA(I)
    END DO  
!       DO I=1,NNODE
!          SIGMA=0.D0
!          DO J=1,NNODE
!             SIGMA=KER1(I,J)+SIGMA
!          END DO
!          KER1(I,I)=-SIGMA
!       END DO

      RETURN
      END
!**********************************************************************
       SUBROUTINE SOLVE_LAPACK(NPL,PHI,PPHI,KER1,KER2,NNODE,NELEM,BUNTYP)
!**********************************************************************
       IMPLICIT NONE
       INTEGER I,J,K,L,N,NPL,NNODE,NELEM(NPL),BUNTYP(NPL)
	   INTEGER INFO,IPIV(NNODE)
       REAL*8 PHI(NNODE),PPHI(NNODE),KER1(NNODE,NNODE),KER2(NNODE,NNODE)
       REAL*8 H1(NNODE,NNODE),Q1(NNODE),G1(NNODE,NNODE),P1(NNODE)

!-----MOVE PHI AND PPHI----         
       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               Q1(J)=PHI(J)
            ELSE
               Q1(J)=PPHI(J)
            END IF
          END DO
          N=N+(NELEM(I)+1)
       END DO

!-----MOVE KER1 AND KER2---- 
         DO I=1,NNODE
           N=0
           DO L=1,NPL
             DO J=K+N,(NELEM(L)+1)+N
             IF (BUNTYP(L) .EQ. 1) THEN
               H1(I,J)=KER1(I,J)  !G*UNKNOWN=H*KNOWN
               G1(I,J)=KER2(I,J)
              ELSE
               H1(I,J)=-KER2(I,J)
               G1(I,J)=-KER1(I,J)
             END IF
             END DO
            N=N+(NELEM(L)+1)
          END DO
        END DO

       P1=MATMUL(H1,Q1)

!*************SOLVE BY CALLING LAPACK*********
CALL DGESV(NNODE,1,G1,NNODE,IPIV,P1,NNODE,INFO)

       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               PPHI(J)=P1(J)
            ELSE
               PHI(J)=P1(J)
            END IF
          END DO
          N=N+NELEM(I)+1
       END DO

      RETURN
    END
!**********************************************************************
       SUBROUTINE SOLVE_LAPACK2_1(NPL,PHI,PPHI,KER1,KER2,G1,H1,NNODE,NELEM,BUNTYP)
!**********************************************************************
       IMPLICIT NONE
       INTEGER I,J,K,L,N,NPL,NNODE,NELEM(NPL),BUNTYP(NPL)
	   INTEGER INFO,IPIV(NNODE)
       REAL*8 PHI(NNODE),PPHI(NNODE),KER1(NNODE,NNODE),KER2(NNODE,NNODE)
       REAL*8 H1(NNODE,NNODE),Q1(NNODE),G1(NNODE,NNODE),P1(NNODE)
	   CHARACTER*1 TRANS
       TRANS = 'N'
       
!-----MOVE PHI AND PPHI----         
       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               Q1(J)=PHI(J)
            ELSE
               Q1(J)=PPHI(J)
            END IF
          END DO
          N=N+(NELEM(I)+1)
       END DO
       
!-----MOVE KER1 AND KER2---- 
         DO I=1,NNODE
           N=0
           DO L=1,NPL
             DO J=K+N,(NELEM(L)+1)+N
             IF (BUNTYP(L) .EQ. 1) THEN
               H1(I,J)=KER1(I,J)  !G*UNKNOWN=H*KNOWN
               G1(I,J)=KER2(I,J)
              ELSE
               H1(I,J)=-KER2(I,J)
               G1(I,J)=-KER1(I,J)
             END IF
             END DO
            N=N+(NELEM(L)+1)
          END DO
        END DO

       P1=MATMUL(H1,Q1)
       
!*************SOLVE BY CALLING LAPACK*********
CALL DGETRF(NNODE,NNODE,G1,NNODE,IPIV,INFO)
CALL DGETRS(TRANS,NNODE,1,G1,NNODE,IPIV,P1,NNODE,INFO)
       
       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               PPHI(J)=P1(J)
            ELSE
               PHI(J)=P1(J)
            END IF
          END DO
          N=N+NELEM(I)+1
       END DO
                     
      RETURN
    END
!**********************************************************************
       SUBROUTINE SOLVE_LAPACK2_2(NPL,PHI,PPHI,G1,H1,NNODE,NELEM,BUNTYP)
!**********************************************************************
       IMPLICIT NONE
       INTEGER I,J,K,L,N,NPL,NNODE,NELEM(NPL),BUNTYP(NPL)
	   INTEGER INFO,IPIV(NNODE)
       REAL*8 PHI(NNODE),PPHI(NNODE)
       REAL*8 H1(NNODE,NNODE),Q1(NNODE),G1(NNODE,NNODE),P1(NNODE)
	   CHARACTER*1 TRANS
       TRANS = 'N'
       
!-----MOVE PHI AND PPHI----         
       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               Q1(J)=PHI(J)
            ELSE
               Q1(J)=PPHI(J)
            END IF
          END DO
          N=N+(NELEM(I)+1)
       END DO

       P1=MATMUL(H1,Q1)

!*************SOLVE BY CALLING LAPACK*********
CALL DGETRS(TRANS,NNODE,1,G1,NNODE,IPIV,P1,NNODE,INFO)

       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               PPHI(J)=P1(J)
            ELSE
               PHI(J)=P1(J)
            END IF
          END DO
          N=N+NELEM(I)+1
       END DO

      RETURN
      END
!********************************************************************
      SUBROUTINE TAYES1(NPL,NFL,NBT,NNODE,NELM,ME,NS,LN,NODE,NORM,JCB,&
                       &PHI,PPHI,DPDS,DP,PHIT,DPDT,DEP,GRAV,MU,VEL1,VEL2)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,NPL,NFL,NBT,NNODE,NELM,ME(NPL),NS(NPL),LN(NELM,2)
    REAL*8 DEP,GRAV,MU,VEL1,VEL2,TEMP1,TEMP2
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE)
    REAL*8 DP(NNODE,2),DPDS(NNODE),PHIT(NNODE),DPDT(NNODE)

	DPDS=0.D0
!*********************ON RIGID BODY*********************
    DO I=ME(1)+1,ME(NFL+1)
    DO J=1,2
        DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
	    DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
    END DO
    END DO

!********************* ON FREE SURFACE 1 *********************
    DO I=1,ME(1)
    DO J=1,2
		IF(LN(I,J).EQ.1) THEN
            DP(LN(I,J),1)=-PPHI(NNODE)
            DPDS(LN(I,J))=(DP(LN(I,J),1)-PPHI(LN(I,J))*NORM(I,1))/NORM(I,2)
            DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
        ELSE IF(LN(I,J).EQ.NS(1)) THEN
            TEMP1=PPHI(NS(1)+1)-PPHI(NS(1))*(NORM(I,1)*NORM(I+1,1)+NORM(I,2)*NORM(I+1,2))
            TEMP2=NORM(I,2)*NORM(I+1,1)-NORM(I,1)*NORM(I+1,2)
            DPDS(LN(I,J))=TEMP1/TEMP2
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

    DO I=1,NS(1)
	  DPDT(I)=0.5D0*(DP(I,1)**2+DP(I,2)**2)-GRAV*(NODE(I,2)-DEP)-MU*PHI(I) !-GRAV*NODE(I,2)-MU*PHI(I) !
      PHIT(I)=DPDT(I)-(DP(I,1)**2+DP(I,2)**2)
    END DO

!********************* ON FREE SURFACE 2 *********************
    DO I=ME(NFL+1)+1,ME(NFL+2)
    DO J=1,2
		IF(LN(I,J).EQ.NS(NFL+1)+1) THEN
            TEMP1=PPHI(NS(NFL+1))-PPHI(NS(NFL+1)+1)*(NORM(I,1)*NORM(I-1,1)+NORM(I,2)*NORM(I-1,2))
            TEMP2=NORM(I,2)*NORM(I-1,1)-NORM(I,1)*NORM(I-1,2)
            DPDS(LN(I,J))=TEMP1/TEMP2
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE IF(LN(I,J).EQ.NS(NFL+2)) THEN
		    DP(LN(I,J),1)=PPHI(NS(NFL+2)+1)
            DPDS(LN(I,J))=(DP(LN(I,J),1)-PPHI(LN(I,J))*NORM(I,1))/NORM(I,2)
            DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

    DO I=NS(NFL+1)+1,NS(NFL+2)
	  DPDT(I)=0.5D0*(DP(I,1)**2+DP(I,2)**2)-GRAV*(NODE(I,2)-DEP)-MU*PHI(I) !-GRAV*NODE(I,2)-MU*PHI(I) !
      PHIT(I)=DPDT(I)-(DP(I,1)**2+DP(I,2)**2)
    END DO

!*********************ON RIGHT WALL*********************
    DO I=ME(NFL+2)+1,ME(NFL+3)
    DO J=1,2
		IF(LN(I,J).EQ.NS(NFL+2)+1) THEN
			DPDS(LN(I,J))=-DP(NS(NFL+2),2)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE IF(LN(I,J).EQ.NS(NFL+3)) THEN
			DPDS(LN(I,J))=0.D0
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

!*********************LEFT WALL*********************
    DO I=ME(NPL-1)+1,ME(NPL)
    DO J=1,2
		IF(LN(I,J).EQ.NS(NPL-1)+1) THEN
			DPDS(LN(I,J))=0.D0
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE IF(LN(I,J).EQ.NNODE) THEN
			DPDS(LN(I,J))=DP(1,2)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

!*********************BOTTOM*********************
    DO I=ME(NPL-NBT-1)+1,ME(NPL-1)
    DO J=1,2
		IF(LN(I,J).EQ.NS(NPL-NBT-1)+1) THEN
          DPDS(LN(I,J))=-PPHI(NS(NPL-NBT-1))
		  DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
          DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE IF(LN(I,J).EQ.NS(NPL-1)) THEN
          DPDS(LN(I,J))=PPHI(NS(NPL-1)+1)
		  DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
          DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
		  DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
		  DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
		  DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

      RETURN
    END
!********************************************************************
      SUBROUTINE ACCBC_TSAO(NPL,NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI,PPHI,DP,ACCMO)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,N,NPL,NNODE,NELM,NELEM(NPL),ME(NPL),LN(NELM,2)
    REAL*8 DPNDX,DPNDY,DPNDS,DPDS
	REAL*8 NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),DP(NNODE,2),ACCMO(NNODE)
N=0
DO K=1,NPL
  DO I=N+1,ME(K)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        ACCMO(LN(I,J))=DPNDS*DPDS/JCB(I)-DPNDS*DPDS ! PHINN=PHISS=0 FOR LINEAR ELEMENT
!        ACCMO(LN(I,J))=DPNDS*DPDS/JCB(I)-DPNDS*(DP(LN(I,J),1)*NORM(I,2)-DP(LN(I,J),2)*NORM(I,1))
    END DO
  END DO
  N=ME(K)
END DO

      RETURN
    END
!********************************************************************
      SUBROUTINE ACCBC_KO(NPL,NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI,PPHI,DP,ACCMO)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,N,NPL,NNODE,NELM,NELEM(NPL),ME(NPL),LN(NELM,2)
    REAL*8 DPNDX,DPNDY,DPNDS,DPDS
	REAL*8 NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),DP(NNODE,2),ACCMO(NNODE)
N=0
DO K=1,NPL
  DO I=N+1,ME(K)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        ACCMO(LN(I,J))=-DPNDS*DPDS ! PHINN=PHISS=0 FOR LINEAR ELEMENT
!		DPNDX=DPNDS*NORM(I,2)	
!		DPNDY=-DPNDS*NORM(I,1)
!		ACCMO(LN(I,J))=DP(LN(I,J),1)*DPNDX+DP(LN(I,J),2)*DPNDY
    END DO
  END DO
  N=ME(K)
END DO

      RETURN
    END
!********************************************************************
      SUBROUTINE ACCBC_GUERBER(NPL,NFL,NNODE,NELM,ME,LN,NODE,NORM,JCB,PHI,PPHI,Z0,Z1,ACCMO)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,NPL,NFL,NNODE,NELM,ME(NPL),LN(NELM,2)
    REAL*8 DX,DY,VX,VY,DPNDS,DPDS,Z0(3),Z1(3)
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),ACCMO(NNODE)

  DO I=ME(2)+1,ME(NFL+1)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        DX=NODE(LN(I,J),1)-Z0(1)
        DY=NODE(LN(I,J),2)-Z0(2)
        VX=Z1(1)-Z1(3)*DY
        VY=Z1(2)+Z1(3)*DX
        ACCMO(LN(I,J))=Z1(3)*(VX*NORM(I,2)-VY*NORM(I,1)-DPDS)-DPNDS*(VX*NORM(I,2)-VY*NORM(I,1))
    END DO
  END DO

      RETURN
    END
!********************************************************************
      SUBROUTINE ACCBC_GRILLI(NPL,NFL,NNODE,NELM,ME,LN,NODE,NORM,JCB,PHI,PPHI,Z0,Z1,ACCMO)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,NPL,NFL,NNODE,NELM,ME(NPL),LN(NELM,2)
    REAL*8 DX,DY,VX,VY,DPNDS,DPDS,Z0(3),Z1(3)
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),ACCMO(NNODE)

  DO I=ME(2)+1,ME(NFL+1)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        
        DX=NODE(LN(I,J),1)-Z0(1)
        DY=NODE(LN(I,J),2)-Z0(2)
        VX=Z1(1)-Z1(3)*DY
        VY=Z1(2)+Z1(3)*DX
        ACCMO(LN(I,J))=-DPNDS*(VX*NORM(I,2)-VY*NORM(I,1))*(JCB(I)+1.D0)/JCB(I)+DPNDS*DPDS/JCB(I)
    END DO
  END DO

      RETURN
    END 
!********************************************************************
      SUBROUTINE ACCBC_CAO(NPL,NFL,NNODE,NELM,ME,LN,NODE,NORM,JCB,PHI,PPHI,Z0,Z1,ACCMO)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,NPL,NFL,NNODE,NELM,ME(NPL),LN(NELM,2)
    REAL*8 DX,DY,VX,VY,DPNDS,DPDS,Z0(3),Z1(3)
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),ACCMO(NNODE)

  DO I=ME(2)+1,ME(NFL+1)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
        
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        DX=NODE(LN(I,J),1)-Z0(1)
        DY=NODE(LN(I,J),2)-Z0(2)
        VX=Z1(1)-Z1(3)*DY
        VY=Z1(2)+Z1(3)*DX
        ACCMO(LN(I,J))=0.D0
        
    END DO
  END DO

      RETURN
    END    
!********************************************************************
SUBROUTINE BOUNDT(DORTYP1,DORTYP2,NDOF,NPL,NFL,NNODE,NELM,NELEM,ME,NS,LN,BUNTYP,&
                &NODE,NORM,PHIT,PPHIT,DPDS,JCB,ACC1,ACC2,ACCMO,Z0,Z1,Z2,WC1,WC2)
!********************************************************************
IMPLICIT NONE
INTEGER I,J,K,N,DORTYP1,DORTYP2,NDOF,NPL,NFL,NNODE,NELM,NS(NPL),ME(NPL),NELEM(NPL),BUNTYP(NPL),LN(NELM,2)
REAL*8 AX,AY,DX,DY,R,ACC1,ACC2,WC1,WC2
REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHIT(NNODE),PPHIT(NNODE)
REAL*8 DPDS(NNODE),DPDSS(NNODE),ACCMO(NNODE)
REAL*8 Z0(3*NDOF),Z1(3*NDOF),Z2(3*NDOF)

!---PREPARE RADIATION CONDITION
!    DO I=ME(NFL+2)+1,ME(NFL+3)
!    DO J=1,2
!		IF(LN(I,J).EQ.NS(NFL+3)) THEN
!		  DPDSS(LN(I,J))=0.D0 ! ASSUME A FLAT GROUND SO VN=0
!		ELSE
!		  DPDSS(LN(I,J))=0.D0 ! DPDSS=0 FOR 2D LINEAR BEM !0.5D0*(-DPDS(LN(I,1))+DPDS(LN(I,2)))/JCB(I)
!		END IF
!    END DO
!    END DO
DPDSS=0.D0

N=0
DO I=1,NPL ! PLANE NUMBER
    DO J=N+1,ME(I) ! ELEMENT NUMBER
        DO K=1,2   ! LN(J,K) = NODE NUMBER
            IF (BUNTYP(I) .EQ. 1)THEN           ! BC FOR FREE SURFACE
                PHIT(LN(J,K))=PHIT(LN(J,K))
                PPHIT(LN(J,K))=0.D0
            ELSE
                IF (I==(NFL+3))THEN               ! BC FOR RIGHT SIDE
                    IF(DORTYP2==0)THEN
                        PPHIT(LN(J,K))=0.D0
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP2==1)THEN
                        PPHIT(LN(J,K))=ACC2+ACCMO(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP2==2)THEN
                        PPHIT(LN(J,K))=ACC2**DSQRT((NODE(LN(J,K),1)-NODE(NS(NPL-1),1))**2+&
                                &(NODE(LN(J,K),2)-NODE(NS(NPL-1),2))**2)+ACCMO(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP2==3)THEN
                        PPHIT(LN(J,K))=WC2*DPDSS(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    END IF
                ELSE IF (I==NPL)THEN              ! BC FOR LEFT SIDE
                    IF(DORTYP1==0)THEN
                        PPHIT(LN(J,K))=0.D0
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP1==1)THEN
                        PPHIT(LN(J,K))=-ACC1+ACCMO(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP1==2)THEN
                        PPHIT(LN(J,K))=-ACC1**DSQRT((NODE(LN(J,K),1)-NODE(NS(NPL-1),1))**2+&
                                &(NODE(LN(J,K),2)-NODE(NS(NPL-1),2))**2)+ACCMO(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    ELSE IF(DORTYP1==3)THEN
                        PPHIT(LN(J,K))=WC1*DPDSS(LN(J,K))
                        PHIT(LN(J,K))=0.D0
                    END IF
                ELSE IF (I>1.AND.I<=(NFL+1))THEN  ! BC FOR RIGID BODY
                    DX=NODE(LN(J,K),1)-Z0(1)
                    DY=NODE(LN(J,K),2)-Z0(2)
                    AX=Z2(1)-Z2(3)*DY-Z1(3)*Z1(3)*DX
                    AY=Z2(2)+Z2(3)*DX-Z1(3)*Z1(3)*DY
                    PPHIT(LN(J,K))=AX*NORM(J,1)+AY*NORM(J,2)+ACCMO(LN(J,K))                 
                    PHIT(LN(J,K))=0.D0
                ELSE                              ! BC FOR BOTTOM
                    PPHIT(LN(J,K))=0.D0
                    PHIT(LN(J,K))=0.D0
                END IF
            END IF
        END DO
    END DO
    N=ME(I)
END DO

RETURN
END
!**********************************************************************
      SUBROUTINE TAYES2(NPL,NFL,NNODE,NELM,NS,ME,LN,NODE,NORM,JCB,PHI,PPHI,PHIT,PPHIT,&
                       &DP,DPDS,DPDT,D2PDT,D2P,DELTTIME,GRAV,ACC1,ACC2,Z2)
!**********************************************************************
      IMPLICIT INTEGER (I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER  NPL,NFL,NNODE,NELM,NS(NPL),ME(NPL),LN(NELM,2)
      REAL*8 ACC1,ACC2,DELTTIME,GRAV,DPTDS,DPDNDS,Z2(3)
      REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM)
      REAL*8 PHI(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE)
      REAL*8 DP(NNODE,2),DPDS(NNODE),DPDT(NNODE),D2PDT(NNODE),D2P(NNODE,2)

!********************* ON FREE SURFACE 1 *********************
	DO I=1,ME(1)
	  DO J=1,2
		IF(LN(I,J).EQ.1)THEN
            D2P(LN(I,J),1)=ACC1
            DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
            DPTDS=(D2P(LN(I,J),1)-PPHI(1)*DPDNDS*NORM(I,2)-(DPDS(1)*DPDNDS+PPHIT(1))*NORM(1,1))/NORM(1,2)
            D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
        ELSE IF (LN(I,J).EQ.NS(1))THEN
!+++++++++++++++++++++++may be revised for continu
            DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
		ELSE
			DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
		END IF
		D2PDT(LN(I,J))=DP(LN(I,J),1)*D2P(LN(I,J),1)+DP(LN(I,J),2)*D2P(LN(I,J),2)-GRAV*DP(LN(I,J),2)
	  END DO
    END DO

!********************* ON FREE SURFACE 2 *********************
	DO I=ME(NFL+1)+1,ME(NFL+2)
	  DO J=1,2
		IF(LN(I,J).EQ.NS(NFL+1)+1)THEN
!+++++++++++++++++++++++may be revised for continu
			DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
        ELSE IF(LN(I,J).EQ.NS(NFL+2))THEN
            D2P(LN(I,J),1)=ACC2 !PPHIT(NS(NFL+2)+1)+ACCMO(NS(NFL+2)+1)
            DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
            DPTDS=(D2P(LN(I,J),1)-PPHI(1)*DPDNDS*NORM(I,2)-(DPDS(1)*DPDNDS+PPHIT(1))*NORM(1,1))/NORM(1,2)
            D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)    
        ELSE
			DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
		END IF
		D2PDT(LN(I,J))=DP(LN(I,J),1)*D2P(LN(I,J),1)+DP(LN(I,J),2)*D2P(LN(I,J),2)-GRAV*DP(LN(I,J),2)
	  END DO
    END DO

      RETURN
      END
!********************************************************************
SUBROUTINE PRESSURE(ICON,THO,GRAV,DEP,NPL,NFL,NNODE,NS,NODE,PHIT,DP,PR,P_ATM)
!********************************************************************
      IMPLICIT NONE
      INTEGER  I,ICON,NPL,NFL,NNODE,NS(NPL)
      REAL*8 DEP,THO,GRAV,P1,P2,P3,P_ATM
      REAL*8 NODE(NNODE,2),PHIT(NNODE),DP(NNODE,2),PR(NNODE)
	  REAL*8 CP1(NS(NFL+2)),CP2(NS(NFL+2)),CP3(NS(NFL+2)),CP(NS(NFL+2))

!----ATOM PRESSURE (BERNOULLI CONSTANT) ON THE FREE SURFACE
	DO I=ICON,ICON !1,NS(1) !
	CP1(I)=THO*PHIT(I)
	CP2(I)=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
	CP3(I)=THO*GRAV*(NODE(I,2)-DEP) !NODE(I,2) !
	CP(I)=CP1(I)+CP2(I)+CP3(I)
    ENDDO
!	DO I=NS(1+NFL)+1,NS(2+NFL) !ICON,ICON !
!	CP1(I)=THO*PHIT(I)
!	CP2(I)=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
!	CP3(I)=THO*GRAV*(NODE(I,2)-DEP)
!	CP(I)=CP1(I)+CP2(I)+CP3(I)
!    ENDDO   
!    WRITE(24,"(500(E15.8,1X))") TIME,CP(1:NS(1)),CP(NS(1+NFL)+1:NS(2+NFL))
    
	P_ATM=CP(ICON)

!----PRESSURE ON FLOATING BODY
	DO I=NS(1)+1,NS(NFL+1)
	P1=THO*PHIT(I)
	P2=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
	P3=THO*GRAV*(NODE(I,2)-DEP) !NODE(I,2) !
	PR(I)=P_ATM-(P1+P2+P3)
    END DO
    
!----PRESSURE ON WALL AND BOTTOM
	DO I=NS(NFL+2)+1,NNODE
	P1=THO*PHIT(I)
	P2=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
	P3=THO*GRAV*(NODE(I,2)-DEP) !NODE(I,2) !
	PR(I)=P_ATM-(P1+P2+P3)
	END DO

    RETURN
    END
!********************************************************************
	SUBROUTINE FORCE_WAVE(TIME,GRAV,MB,NPL,NFL,NNODE,NELM,ME,LN,NODE,NORM,JCB,PR,Z0,FOR)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,NPL,NFL,NNODE,NELM,ME(NPL),LN(NELM,2)
	REAL*8 P1(2),P2(2),R1(2),R2(2),M1,M2
	REAL*8 TIME,GRAV,MB,Z0(3),FOR(3)
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PR(NNODE)

	FOR=0.D0
	DO I=ME(1)+1,ME(1+NFL)
!--- FORCE ALONG X- AND Y-DIRECTION
        P1(1)=PR(LN(I,1))*NORM(I,1)
        P1(2)=PR(LN(I,1))*NORM(I,2)
        P2(1)=PR(LN(I,2))*NORM(I,1)
        P2(2)=PR(LN(I,2))*NORM(I,2)     
		FOR(1)=FOR(1)+JCB(I)*(P1(1)+P2(1)) ! NOTE JCB=0.5*LENG
		FOR(2)=FOR(2)+JCB(I)*(P1(2)+P2(2))
!--- MOMENT ALONG Z-DIRECTION
		R1(1)=NODE(LN(I,1),1)-Z0(1)
		R1(2)=NODE(LN(I,1),2)-Z0(2)
		R2(1)=NODE(LN(I,2),1)-Z0(1)
		R2(2)=NODE(LN(I,2),2)-Z0(2)
        M1=R1(1)*P1(2)-R1(2)*P1(1)      ! moment = p(r x n)
        M2=R2(1)*P2(2)-R2(2)*P2(1)
		FOR(3)=FOR(3)+JCB(I)*(M1+M2)
    END DO
    
	FOR(2)=FOR(2)-MB*GRAV
    
	RETURN
    END
!********************************************************************
	SUBROUTINE STR(IDOF,GAMMA,BETA,NDOF,DELTTIME,MB,IB,FOR2,FOR,Z0,Z1,Z2,Z0_PC,Z1_PC,Z2_PC)
!********************************************************************
! THIS SIMPLE CALCULATION IS ONLY AVAILABLE WHEN NDOF = 1     
	IMPLICIT NONE
	INTEGER NDOF,IDOF(3)
    REAL*8 GAMMA,BETA,DELTTIME,MB,IB,FOR(3),FOR2(3)
	REAL*8 Z0(3*NDOF),Z1(3*NDOF),Z2(3*NDOF)
    REAL*8 Z0_PC(3*NDOF),Z1_PC(3*NDOF),Z2_PC(3*NDOF)
        
!--- SOLVE TRANSLATIONAL MOTION IN X-DIRECTION  
    IF (IDOF(1)==1)THEN
        Z2_PC(1)=(FOR(1)+FOR2(1))/MB
        Z1_PC(1)=Z1(1)+DELTTIME*((1-GAMMA)*Z2(1)+GAMMA*Z2_PC(1))
        Z0_PC(1)=Z0(1)+DELTTIME*Z1(1)+DELTTIME**2*((0.5D0-BETA)*Z2(1)+BETA*Z2_PC(1))
    ELSE
        Z2_PC(1)=Z2(1)
        Z1_PC(1)=Z1(1)
        Z0_PC(1)=Z0(1)
    END IF

!--- SOLVE TRANSLATIONAL MOTION IN Y-DIRECTION
    IF (IDOF(2)==1)THEN
        Z2_PC(2)=(FOR(2)+FOR2(2))/MB
        Z1_PC(2)=Z1(2)+DELTTIME*((1-GAMMA)*Z2(2)+GAMMA*Z2_PC(2))
        Z0_PC(2)=Z0(2)+DELTTIME*Z1(2)+DELTTIME**2*((0.5D0-BETA)*Z2(2)+BETA*Z2_PC(2))
    ELSE
        Z2_PC(2)=Z2(2)
        Z1_PC(2)=Z1(2)
        Z0_PC(2)=Z0(2)
    END IF
    
!--- SOLVE ROTATIONAL MOTION
    IF (IDOF(3)==1)THEN
        Z2_PC(3)=(FOR(3)+FOR2(3))/IB
        Z1_PC(3)=Z1(3)+DELTTIME*((1-GAMMA)*Z2(3)+GAMMA*Z2_PC(3))
        Z0_PC(3)=Z0(3)+DELTTIME*Z1(3)+DELTTIME**2*((0.5D0-BETA)*Z2(3)+BETA*Z2_PC(3))
    ELSE
        Z2_PC(3)=Z2(3)
        Z1_PC(3)=Z1(3)
        Z0_PC(3)=Z0(3)
    END IF

	RETURN
    END
!********************************************************************
	SUBROUTINE STR_EQTLD(IDOF,GAMMA,BETA,GRAV,A,NDOF,NDOFTLD,DELTTIME,MB,IB,TMW,MFIX,HFIX,IFIX,EQM,EQC,EQK,&
                        &EQM_ALL,EQC_ALL,EQK_ALL,EQH,K_EFF,B1,B2,FOR,Z0,Z1,Z2,Z0_PC,Z1_PC,Z2_PC,&
                        &EQZ0,EQZ1,EQZ2,EQZ0_PC,EQZ1_PC,EQZ2_PC,X0_IC,FOR2)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,NDOF,NDOFTLD,IDOF(3)
    INTEGER INFO,IPIV(NDOFTLD+1)
    REAL*8 GAMMA,BETA,GRAV,DELTTIME,MB,IB,TMW,MFIX,HFIX,IFIX,FOR(3),FOR2(3),A(8)
	REAL*8 Z0(3*NDOF),Z1(3*NDOF),Z2(3*NDOF)
    REAL*8 Z0_PC(3*NDOF),Z1_PC(3*NDOF),Z2_PC(3*NDOF)
	REAL*8 EQZ0(NDOFTLD),EQZ1(NDOFTLD),EQZ2(NDOFTLD)
    REAL*8 EQZ0_PC(NDOFTLD),EQZ1_PC(NDOFTLD),EQZ2_PC(NDOFTLD)
    REAL*8 EQM(NDOFTLD),EQC(NDOFTLD),EQK(NDOFTLD),EQH(NDOFTLD)
    REAL*8 EQM_ALL(NDOFTLD+1,NDOFTLD+1),EQC_ALL(NDOFTLD+1,NDOFTLD+1),EQK_ALL(NDOFTLD+1,NDOFTLD+1)
    REAL*8 K_EFF(NDOFTLD+1,NDOFTLD+1),F_EFF(NDOFTLD+1),F(NDOFTLD+1),X0_IC(NDOFTLD+1)
    REAL*8 X0(NDOFTLD+1),X1(NDOFTLD+1),X2(NDOFTLD+1)
    REAL*8 X0_PC(NDOFTLD+1),X1_PC(NDOFTLD+1),X2_PC(NDOFTLD+1)
    REAL*8 B1(NDOFTLD+1),B2(NDOFTLD+1)
    
!--- SOLVE TRANSLATIONAL MOTION IN X-DIRECTION
    IF (IDOF(1)==1)THEN
    !---TRASLATE TO LOCAL COORDINATE X AND SOLVE EFFECTIVE EQUATIONS
        X0(1)=Z0(1)-X0_IC(1)
        X0(2:NDOFTLD+1)=EQZ0-X0_IC(2:NDOFTLD+1)
        X1(1)=Z1(1)
        X1(2:NDOFTLD+1)=EQZ1
        X2(1)=Z2(1)
        X2(2:NDOFTLD+1)=EQZ2
        
        F=B1*FOR(1)+B2*Z2(3)
        F_EFF=F+MATMUL(EQM_ALL,(A(1)*X0+A(3)*X1+A(4)*X2))+MATMUL(EQC_ALL,(A(2)*X0+A(5)*X1+A(6)*X2))
        CALL DGESV(NDOFTLD+1,1,K_EFF,NDOFTLD+1,IPIV,F_EFF,NDOFTLD+1,INFO)

    !---SOLVE BY NEWMARK
        X0_PC=F_EFF        
        X2_PC=A(1)*(X0_PC-X0)-A(3)*X1-A(4)*X2
        X1_PC=X1+A(7)*X2+A(8)*X2_PC
        
    !---RETURN TO GLOBAL COORDINATE
        Z0_PC(1)=X0_PC(1)+X0_IC(1)
        Z1_PC(1)=X1_PC(1)
        Z2_PC(1)=X2_PC(1)
        EQZ0_PC=X0_PC(2:NDOFTLD+1)+X0_IC(2:NDOFTLD+1)
        EQZ1_PC=X1_PC(2:NDOFTLD+1)
        EQZ2_PC=X2_PC(2:NDOFTLD+1)
    ELSE
        Z2_PC(1)=Z2(1)
        Z1_PC(1)=Z1(1)
        Z0_PC(1)=Z0(1)
    END IF

!--- SOLVE TRANSLATIONAL MOTION IN Y-DIRECTION
    FOR2(2)=-TMW*GRAV
    
    IF (IDOF(2)==1)THEN
        Z2_PC(2)=(FOR(2)+FOR2(2))/MB
        Z1_PC(2)=Z1(2)+DELTTIME*((1-GAMMA)*Z2(2)+GAMMA*Z2_PC(2))
        Z0_PC(2)=Z0(2)+DELTTIME*Z1(2)+DELTTIME**2*((0.5D0-BETA)*Z2(2)+BETA*Z2_PC(2))
    ELSE
        Z2_PC(2)=Z2(2)
        Z1_PC(2)=Z1(2)
        Z0_PC(2)=Z0(2)
    END IF
    
!--- SOLVE ROTATIONAL MOTION
    IF (IDOF(3)==1)THEN
        !---CALCULATE TLD MOMENT
        FOR2(1)=0.D0
        FOR2(3)=0.D0
        DO I=1,NDOFTLD
            !--- use the kth response ---
            FOR2(1)=FOR2(1)+EQK(I)*(EQH(I)*Z0(3)+X0(I+1)-X0(1))&
                          &+EQC(I)*(EQH(I)*Z1(3)+X1(I+1)-X1(1)) 
            FOR2(3)=FOR2(3)-EQK(I)*(EQH(I)*Z0(3)+X0(I+1)-X0(1))*EQH(I)&
                          &-EQC(I)*(EQH(I)*Z1(3)+X1(I+1)-X1(1))*EQH(I)
            !--- use the (k+1)th response ---
!            FOR2(1)=FOR2(1)+EQK(I)*(EQH(I)*Z0(3)+X0_PC(I+1)-X0_PC(1))&
!                          &+EQC(I)*(EQH(I)*Z1(3)+X1_PC(I+1)-X1_PC(1))
!            FOR2(3)=FOR2(3)-EQK(I)*(EQH(I)*Z0(3)+X0_PC(I+1)-X0_PC(1))*EQH(I)&
!                          &-EQC(I)*(EQH(I)*Z1(3)+X1_PC(I+1)-X1_PC(1))*EQH(I)
            ! note that Counterclockwise MOMENT IS + 
        END DO

        !---SOLVE BY NEWMARK
        Z2_PC(3)=(FOR(3)+FOR2(3))/(IB+IFIX)
        Z1_PC(3)=Z1(3)+DELTTIME*((1-GAMMA)*Z2(3)+GAMMA*Z2_PC(3))
        Z0_PC(3)=Z0(3)+DELTTIME*Z1(3)+DELTTIME**2*((0.5D0-BETA)*Z2(3)+BETA*Z2_PC(3))
    ELSE
        Z2_PC(3)=Z2(3)
        Z1_PC(3)=Z1(3)
        Z0_PC(3)=Z0(3)
    END IF

	RETURN
    END
!**********************************************************************
SUBROUTINE ENERGY_WAVE(DORTYP1,DORTYP2,NPL,NFL,NNODE,ME,NELM,LN,NGA,NODE,NODE_TEMP,PHI,PPHI,PHIT,PPHIT,DP,PR,&
                     &NORM,JCB,WT,SH,SHA1,SHA2,GRAV,THO,KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)
!**********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,M,DORTYP1,DORTYP2,NNODE,NGA,NPL,NFL,NELM,ME(NPL),LN(NELM,2)
    REAL*8 NODE(NNODE,2),PHI(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE),DP(NNODE,2),PR(NNODE)
    REAL*8 NODE_TEMP(NNODE,2),NORM(NELM,2),JCB(NELM),WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)
    REAL*8 GRAV,THO,DN1,DN2,TEMP
    REAL*8 XFUNC(NGA),YFUNC(NGA),PFUNC(NGA),PPFUNC(NGA)
    REAL*8 PTFUNC(NGA),PPTFUNC(NGA),DPXFUNC(NGA),DPYFUNC(NGA)
    REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT
	    
!-----KE AND DT/DT
    KE=0.D0
	DTDT=0.D0
	DO J=1,NELM     
		DO M=1,NGA
			PFUNC(M)=SHA1(M)*PHI(LN(J,1))+SHA2(M)*PHI(LN(J,2))
			PPFUNC(M)=SHA1(M)*PPHI(LN(J,1))+SHA2(M)*PPHI(LN(J,2))
			PTFUNC(M)=SHA1(M)*PHIT(LN(J,1))+SHA2(M)*PHIT(LN(J,2))
			PPTFUNC(M)=SHA1(M)*PPHIT(LN(J,1))+SHA2(M)*PPHIT(LN(J,2))
		END DO
		DO K=1,2
			DO M=1,NGA
			KE=KE+PFUNC(M)*PPFUNC(M)*JCB(J)*SH(K,M)*WT(M)
			DTDT=DTDT+(PTFUNC(M)*PPFUNC(M)+PFUNC(M)*PPTFUNC(M))*JCB(J)*SH(K,M)*WT(M)
			END DO
		END DO
    END DO

	KE=KE*0.5D0*THO
    DTDT=DTDT*0.5D0*THO

!-----PE AND DV/DT
    PE=0.D0
	DVDT=0.D0
!	DO J=1,ME(2+NFL)
!		DO M=1,NGA
!			XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
!			YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
!			DPXFUNC(M)=SHA1(M)*DP(LN(J,1),1)+SHA2(M)*DP(LN(J,2),1)
!			DPYFUNC(M)=SHA1(M)*DP(LN(J,1),2)+SHA2(M)*DP(LN(J,2),2)
!		END DO
!		DO K=1,2
!			DO M=1,NGA
!			PE=PE+YFUNC(M)**2*JCB(J)*SH(K,M)*WT(M)
!			DVDT=DVDT+YFUNC(M)*DPYFUNC(M)*JCB(J)*SH(K,M)*WT(M)
!			END DO
!		END DO
!    END DO 
	DO J=1,ME(2+NFL)
        TEMP=0.5D0*(NODE(LN(J,1),2)+NODE(LN(J,2),2))
        PE=PE+0.5D0*(NODE(LN(J,2),1)-NODE(LN(J,1),1))*TEMP**2
        DVDT=DVDT+0.5D0*(DP(LN(J,1),2)*NODE(LN(J,1),2)+DP(LN(J,2),2)*NODE(LN(J,2),2))*(NODE(LN(J,2),1)-NODE(LN(J,1),1))
    END DO
    
    PE=PE*THO*GRAV-PE0
	DVDT=DVDT*THO*GRAV

!-----TOTAL ENERGY TIME DERIVATIVE
    TE=KE+PE
	DEDT=DTDT+DVDT

!-----WORK AND POWER TO WATER TANK
    WORK=0.D0
    DWDT=0.D0
    IF (DORTYP1==1)THEN
    DO I=ME(NPL-1)+1,NELM
	    TEMP=DSQRT((NODE(LN(I,1),1)-NODE(LN(I,2),1))**2+(NODE(LN(I,1),2)-NODE(LN(I,2),2))**2)        
        DN1=(NODE(LN(I,1),1)-NODE_TEMP(LN(I,1),1))*NORM(I,1)+(NODE(LN(I,1),2)-NODE_TEMP(LN(I,1),2))*NORM(I,2)
        DN2=(NODE(LN(I,2),1)-NODE_TEMP(LN(I,2),1))*NORM(I,1)+(NODE(LN(I,2),2)-NODE_TEMP(LN(I,2),2))*NORM(I,2)
        WORK=WORK-(PR(LN(I,1))*DN1+PR(LN(I,2))*DN2)*TEMP/2.D0 ! THE PRESSURE/FORCE DIRECTION IS X-
        DWDT=DWDT+(PR(LN(I,1))*PPHI(LN(I,1))+PR(LN(I,2))*PPHI(LN(I,2)))*TEMP/2.D0
    END DO
    ELSE IF (DORTYP2==1)THEN
    DO I=ME(2+NFL)+1,ME(NFL+3)
	    TEMP=DSQRT((NODE(LN(I,1),1)-NODE(LN(I,2),1))**2+(NODE(LN(I,1),2)-NODE(LN(I,2),2))**2)        
        DN1=(NODE(LN(I,1),1)-NODE_TEMP(LN(I,1),1))*NORM(I,1)+(NODE(LN(I,1),2)-NODE_TEMP(LN(I,1),2))*NORM(I,2)
        DN2=(NODE(LN(I,2),1)-NODE_TEMP(LN(I,2),1))*NORM(I,1)+(NODE(LN(I,2),2)-NODE_TEMP(LN(I,2),2))*NORM(I,2)
        WORK=WORK+(PR(LN(I,1))*DN1+PR(LN(I,2))*DN2)*TEMP/2.D0
	    DWDT=DWDT+(PR(LN(I,1))*PPHI(LN(I,1))+PR(LN(I,2))*PPHI(LN(I,2)))*TEMP/2.D0
    END DO
    END IF
    
    RETURN
    END 
!**********************************************************************
SUBROUTINE ENERGY_BODY(NPL,NFL,NNODE,ME,NELM,LN,NODE,NODE_TEMP,PPHI,PR,NORM,&
                      &GRAV,MB,IB,Z0,Z1,Z2,KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)
!**********************************************************************
    IMPLICIT NONE
    INTEGER I,NPL,NFL,NNODE,NELM,ME(NPL),LN(NELM,2)
    REAL*8 NODE(NNODE,2),NODE_TEMP(NNODE,2),PPHI(NNODE),PR(NNODE),NORM(NELM,2)
    REAL*8 GRAV,MB,IB,Z0(3),Z1(3),Z2(3)
    REAL*8 DN1,DN2,TEMP
    REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT
    
!-----KE AND DT/DT
    KE=0.5D0*MB*(Z1(1)**2+Z1(2)**2)+0.5D0*IB*Z1(3)**2
	DTDT=MB*(Z1(1)*Z2(1)+Z1(2)*Z2(2))+IB*Z1(3)*Z2(2)

!-----PE AND DV/DT
    PE=MB*GRAV*Z0(2)-PE0
	DVDT=MB*GRAV*Z1(2)

!-----TOTAL ENERGY TIME DERIVATIVE
    TE=KE+PE
	DEDT=DTDT+DVDT

!-----WORK AND POWER BY WAVE AND TLD
    WORK=0.D0
    DWDT=0.D0
!    DO I=ME(1)+1,ME(1+NFL)
!	    TEMP=DSQRT((NODE(LN(I,1),1)-NODE(LN(I,2),1))**2+(NODE(LN(I,1),2)-NODE(LN(I,2),2))**2)        
!        DN1=(NODE(LN(I,1),1)-NODE_TEMP(LN(I,1),1))*NORM(I,1)+(NODE(LN(I,1),2)-NODE_TEMP(LN(I,1),2))*NORM(I,2)
!        DN2=(NODE(LN(I,2),1)-NODE_TEMP(LN(I,2),1))*NORM(I,1)+(NODE(LN(I,2),2)-NODE_TEMP(LN(I,2),2))*NORM(I,2)
!        WORK=WORK+(PR(LN(I,1))*DN1+PR(LN(I,2))*DN2)*TEMP/2.D0
!	    DWDT=DWDT+(PR(LN(I,1))*PPHI(LN(I,1))+PR(LN(I,2))*PPHI(LN(I,2)))*TEMP/2.D0
!    END DO
    
    RETURN
    END
!**********************************************************************
SUBROUTINE ENERGY_TLD(NNODE,NELEM,NELM,NS,LN,NGA,NODE,PHI,PPHI,PHIT,PPHIT,DP,PR,&
                     &NORM,JCB,WT,SH,SHA1,SHA2,POR,GRAV,THO,Z0,Z1,NODE_TEMP,KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)
!**********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,M,NNODE,NGA,NELM,NELEM(4),NS(4),LN(NELM,2)
    REAL*8 NODE(NNODE,2),PHI(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE),DP(NNODE,2),PR(NNODE)
    REAL*8 NORM(NELM,2),JCB(NELM),WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)
    REAL*8 POR,GRAV,THO,Z0(3),Z1(3),NODE_TEMP(NNODE,2)
    REAL*8 XFUNC(NGA),YFUNC(NGA),PFUNC(NGA),PPFUNC(NGA)
    REAL*8 PTFUNC(NGA),PPTFUNC(NGA),DPXFUNC(NGA),DPYFUNC(NGA)
    REAL*8 ITA1,ITA2,YC,ITAH,ITAT,ITAT2,DN1,DN2,S1,S2,TEMP,REF(2)
    REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT
	
    S1=DCOS(Z0(3))
	S2=DSIN(Z0(3))
    
!-----KE AND DT/DT
    KE=0.D0
	DTDT=0.D0
	DO J=1,NELM     
		DO M=1,NGA
			PFUNC(M)=SHA1(M)*PHI(LN(J,1))+SHA2(M)*PHI(LN(J,2))
			PPFUNC(M)=SHA1(M)*PPHI(LN(J,1))+SHA2(M)*PPHI(LN(J,2))
			PTFUNC(M)=SHA1(M)*PHIT(LN(J,1))+SHA2(M)*PHIT(LN(J,2))
			PPTFUNC(M)=SHA1(M)*PPHIT(LN(J,1))+SHA2(M)*PPHIT(LN(J,2))
		END DO
		DO K=1,2
			DO M=1,NGA
			KE=KE+PFUNC(M)*PPFUNC(M)*JCB(J)*SH(K,M)*WT(M)
			DTDT=DTDT+(PTFUNC(M)*PPFUNC(M)+PFUNC(M)*PPTFUNC(M))*JCB(J)*SH(K,M)*WT(M)
			END DO
		END DO
    END DO

	KE=KE*0.5D0*POR*THO
    DTDT=DTDT*0.5D0*POR*THO

!-----PE AND DV/DT
    PE=0.D0
	DVDT=0.D0
!	DO J=1,NELEM(1)
!		DO M=1,NGA
!			XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
!			YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
!			DPXFUNC(M)=SHA1(M)*DP(LN(J,1),1)+SHA2(M)*DP(LN(J,2),1)
!			DPYFUNC(M)=SHA1(M)*DP(LN(J,1),2)+SHA2(M)*DP(LN(J,2),2)
!		END DO
!		DO K=1,2
!			DO M=1,NGA
!			ITA=(XFUNC(M)-Z0(1))*(-S2)+(YFUNC(M)-Z0(2))*S1
!            ITAH=YFUNC(M)-0.5D0*ITA*S1
!			PE=PE+ITA*ITAH*JCB(J)*SH(K,M)*WT(M)
            
!            ITAT=DPXFUNC(M)*(-S2)+DPYFUNC(M)*S1
!            ITAT2=DPYFUNC(M)-0.5D0*ITA*(-S2)*Z1(3)-0.5D0*S1*ITAT
!			DVDT=DVDT+(ITAT*ITAH+ITA*ITAT2)*JCB(J)*SH(K,M)*WT(M)
!			END DO
!		END DO
!    END DO
    REF=NODE(NS(3),:)
    DO J=1,NELEM(1)
        ITA1=(NODE(LN(J,1),1)-REF(1))*(-S2)+(NODE(LN(J,1),2)-REF(2))*S1
        ITA2=(NODE(LN(J,2),1)-REF(1))*(-S2)+(NODE(LN(J,2),2)-REF(2))*S1
        TEMP=(NODE(LN(J,2),1)-NODE(LN(J,1),1))*S1+(NODE(LN(J,2),2)-NODE(LN(J,1),2))*S2
        YC=0.5D0*(NODE(LN(J,1),2)+NODE(LN(J,2),2))-0.5D0*0.5D0*(ITA1+ITA2)*S1
        PE=PE+0.5D0*(ITA1+ITA2)*TEMP*YC

        !DVDT TOO COMPLECATE SO JUST HOLD UP
    END DO
    
    PE=PE*POR*THO*GRAV-PE0
	DVDT=DVDT*POR*THO*GRAV

!-----TOTAL ENERGY TIME DERIVATIVE
    TE=KE+PE
	DEDT=DTDT+DVDT

!-----WORK AND POWER TO WATER TANK
    WORK=0.D0
    DWDT=0.D0
!    DO I=NELEM(1)+1,NELM
!	    TEMP=DSQRT((NODE(LN(I,1),1)-NODE(LN(I,2),1))**2+(NODE(LN(I,1),2)-NODE(LN(I,2),2))**2)        
!        DN1=(NODE(LN(I,1),1)-NODE_TEMP(LN(I,1),1))*NORM(I,1)+(NODE(LN(I,1),2)-NODE_TEMP(LN(I,1),2))*NORM(I,2)
!        DN2=(NODE(LN(I,2),1)-NODE_TEMP(LN(I,2),1))*NORM(I,1)+(NODE(LN(I,2),2)-NODE_TEMP(LN(I,2),2))*NORM(I,2)
!        WORK=WORK+(PR(LN(I,1))*DN1+PR(LN(I,2))*DN2)*TEMP/2.D0
!	    DWDT=DWDT+(PR(LN(I,1))*PPHI(LN(I,1))+PR(LN(I,2))*PPHI(LN(I,2)))*TEMP/2.D0
!    END DO

    RETURN
    END
!**********************************************************************
SUBROUTINE ENERGY_MECH_TLD(NDOFTLD,GRAV,MFIX,IFIX,HFIX,Z0,Z1,Z2,EQM,EQC,EQK,EQH,X0,X1,X2,&
                          &KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)
!**********************************************************************
    IMPLICIT NONE
    INTEGER I,NDOFTLD
    REAL*8 GRAV,MFIX,IFIX,HFIX,Z0(3),Z1(3),Z2(3)
    REAL*8 EQM(NDOFTLD),EQC(NDOFTLD),EQK(NDOFTLD),EQH(NDOFTLD),X0(NDOFTLD),X1(NDOFTLD),X2(NDOFTLD)
    REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT
    
!-----KE AND DT/DT
    KE=0.D0
    DTDT=0.D0
    DO I=1,NDOFTLD
    KE=KE+0.5D0*EQM(I)*X1(I)**2+0.5D0*EQM(I)*(Z1(1)**2+Z1(2)**2)+0.5D0*EQM(I)*(EQH(I)*Z2(3))**2
	DTDT=DTDT+EQM(I)*X1(I)*X2(I)+EQM(I)*(Z1(1)*Z2(1)+Z1(2)*Z2(2)) !+EQM(I)*EQH(I)*2*Z2(3)* ++++THIS PART NEED THE ACCELERATION CHANGE++++
    END DO
    KE=KE+0.5D0*IFIX*Z1(3)**2
    DTDT=DTDT+IFIX*Z1(3)*Z2(3) !+++++I AM TOO TIRED TO CALCULATE THIS ONE...
    
!-----PE AND DV/DT
    PE=0.D0
    DVDT=0.D0
    DO I=1,NDOFTLD
    PE=PE+0.5D0*EQK(I)*X0(I)**2+EQM(I)*GRAV*Z0(2)
	DVDT=DVDT+EQK(I)*X0(I)*X1(I)+EQM(I)*GRAV*Z1(2)
    END DO
    PE=PE+MFIX*GRAV*Z0(2)-PE0

!-----TOTAL ENERGY TIME DERIVATIVE
    TE=KE+PE
	DEDT=DTDT+DVDT

!-----WORK AND POWER BY WAVE
    WORK=0.D0
    DWDT=0.D0
!    DO I=ME(1)+1,ME(1+NFL)
!	    TEMP=DSQRT((NODE(LN(I,1),1)-NODE(LN(I,2),1))**2+(NODE(LN(I,1),2)-NODE(LN(I,2),2))**2)        
!        DN1=(NODE(LN(I,1),1)-NODE_TEMP(LN(I,1),1))*NORM(I,1)+(NODE(LN(I,1),2)-NODE_TEMP(LN(I,1),2))*NORM(I,2)
!        DN2=(NODE(LN(I,2),1)-NODE_TEMP(LN(I,2),1))*NORM(I,1)+(NODE(LN(I,2),2)-NODE_TEMP(LN(I,2),2))*NORM(I,2)
!        WORK=WORK+(PR(LN(I,1))*DN1+PR(LN(I,2))*DN2)*TEMP/2.D0
!	    DWDT=DWDT+(PR(LN(I,1))*PPHI(LN(I,1))+PR(LN(I,2))*PPHI(LN(I,2)))*TEMP/2.D0
!    END DO
    
    RETURN
    END
!******************************************************
      SUBROUTINE DOMAIN(NPL,NGA,NFIELD,NNODE,NELM,NELEM,NS,LN,NODE,NORM,JCB,PHI,PPHI,PHIT,PPHIT,SHA1,SHA2,SH,WT,THO,GRAV,DEP,P_ATM,DP,PR)
!********************************************************************
      IMPLICIT NONE
      INTEGER  I,J,K,L,M,IL,IR,NPL,NGA,NFIELD,NNODE,NELM,NELEM(NPL),NS(NPL),LN(NELM,2)
	  REAL*8 THO,GRAV,DEP,P_ATM
	  REAL*8 HB,DX,DY,PI2,TEMP,P1,P2,P3
	  REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM)
	  REAL*8 PHI(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE),DP(NNODE,2),PR(NNODE)
	  REAL*8 DNODE(NFIELD,2),DVX(NFIELD),DVY(NFIELD),DPHIT(NFIELD),DPR(NFIELD)
	  REAL*8 KER1(NFIELD,NNODE),KER2(NFIELD,NNODE)
      REAL*8 H(2),G(2),XFUNC(10),YFUNC(10),PXI1(2)
	  REAL*8 WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)
	
	PI2=2.D0*DACOS(-1.D0)

!----CREATE DOMAIN POINT
	L=1
	DO I=2,NS(1)-1
	  CALL BWLOC(NODE(I,1),NS(NPL-1)-NS(2),NODE(NS(2)+1:NS(NPL-1),1),NS(2),IL,IR)
	  HB=0.5D0*(NODE(IL,2)+NODE(IR,2))+0.015D0 ! keep it a little far away from the boundary
	  DY=-NODE(I,2)/NELEM(2)
		DO J=2,NELEM(2)
		  TEMP=NODE(I,2)+DY*(J-1)
			IF(TEMP>HB)THEN
			DNODE(L,1)=NODE(I,1)
			DNODE(L,2)=NODE(I,2)+DY*(J-1)
			L=L+1
			END IF
		END DO
	END DO

!--- SET A DUMMY NODE TO USELESS DNODE
	DO I=L,NFIELD
	DNODE(I,:)=DNODE(1,:)
	END DO

	KER1=0.D0
	KER2=0.D0
	DVX=0.D0
!----CALCULATE X VELOCITY BY BIE
	DO I = 1,NFIELD
       DO J=1,NELM
		 DO M=1,NGA
			XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
			YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
		 END DO
		DO K=1,2
         G(K)=0.D0
         H(K)=0.D0
          DO M=1,NGA
			TEMP=JCB(J)*SH(K,M)*WT(M)
            H(K)=H(K)+(((YFUNC(M)-DNODE(I,2))**2-(XFUNC(M)-DNODE(I,1))**2)*NORM(J,1)-2.D0*(YFUNC(M)-DNODE(I,2))*(XFUNC(M)-DNODE(I,1))*NORM(J,2))/((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)**2*TEMP
            G(K)=G(K)+(XFUNC(M)-DNODE(I,1))/((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)*TEMP
         END DO
	     KER1(I,LN(J,K))=KER1(I,LN(J,K))+H(K)
         KER2(I,LN(J,K))=KER2(I,LN(J,K))+G(K)
		END DO
       END DO
      END DO
	DVX=(MATMUL(KER2,PPHI)-MATMUL(KER1,PHI))/PI2

	KER1=0.D0
	KER2=0.D0
	DVY=0.D0
!----CALCULATE Y VELOCITY BY BIE
	DO I = 1,NFIELD
       DO J=1,NELM
		 DO M=1,NGA
			XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
			YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
		 END DO
		DO K=1,2
         G(K)=0.D0
         H(K)=0.D0
          DO M=1,NGA
			TEMP=JCB(J)*SH(K,M)*WT(M)
            H(K)=H(K)+(((XFUNC(M)-DNODE(I,1))**2-(YFUNC(M)-DNODE(I,2))**2)*NORM(J,2)-2.D0*(YFUNC(M)-DNODE(I,2))*(XFUNC(M)-DNODE(I,1))*NORM(J,1))/((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)**2*TEMP
            G(K)=G(K)+(YFUNC(M)-DNODE(I,2))/((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)*TEMP
         END DO
	     KER1(I,LN(J,K))=KER1(I,LN(J,K))+H(K)
         KER2(I,LN(J,K))=KER2(I,LN(J,K))+G(K)
		END DO
       END DO
      END DO
	DVY=(MATMUL(KER2,PPHI)-MATMUL(KER1,PHI))/PI2
	
	KER1=0.D0
	KER2=0.D0
	DPHIT=0.D0
!----CALCULATE PARTIAL POTENTIAL OVER TIME BY BIE
      DO I = 1,NFIELD
       DO J=1,NELM
		 DO M=1,NGA
			XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
			YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
		 END DO
		DO K=1,2
         G(K)=0.D0
         H(K)=0.D0
          DO M=1,NGA
			TEMP=JCB(J)*SH(K,M)*WT(M)
            H(K)=H(K)+(-1)/((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)*((XFUNC(M)-DNODE(I,1))*NORM(J,1)+(YFUNC(M)-DNODE(I,2))*NORM(J,2))*TEMP
            G(K)=G(K)+DLOG(1./((XFUNC(M)-DNODE(I,1))**2+(YFUNC(M)-DNODE(I,2))**2)**0.5)*TEMP	 
		 END DO
	     KER1(I,LN(J,K))=KER1(I,LN(J,K))+H(K)
         KER2(I,LN(J,K))=KER2(I,LN(J,K))+G(K)
		END DO
       END DO
      END DO
	DPHIT=(MATMUL(KER2,PPHIT)-MATMUL(KER1,PHIT))/PI2

!----CALCULATE PRESSURE DISTRIBUTION IN DOMAIN
	DO I=1,NFIELD
	P1=THO*DPHIT(I)
	P2=THO*0.5*(DVX(I)**2+DVY(I)**2)
	P3=THO*GRAV*(DNODE(I,2)-DEP)
	DPR(I)=P_ATM-(P1+P2+P3)
	END DO

	WRITE(12,'(5000(1X,F15.7))') NODE(:,1),DNODE(:,1)
	WRITE(12,'(5000(1X,F15.7))') NODE(:,2),DNODE(:,2)
	WRITE(12,'(5000(1X,F15.7))') DP(:,1),DVX
	WRITE(12,'(5000(1X,F15.7))') DP(:,2),DVY
	WRITE(12,'(5000(1X,F15.7))') PR,DPR

      RETURN
      END
!********************************************************************
      SUBROUTINE GAUSS(WT,RT,NGA)
!********************************************************************
      INTEGER NGA
      REAL*8 WT(NGA),RT(NGA)

      SELECT CASE(NGA)
       CASE(3)
        WT(1)=0.55555555
        WT(2)=0.88888889
        WT(3)=0.55555555
        RT(1)=0.77459667
        RT(2)=0.D0
        RT(3)=-0.77459667
       CASE(4)
        WT(1)=0.65214515
        WT(2)=0.34785484
        WT(3)=0.34785484
        WT(4)=0.65214515
        RT(1)=0.33998104
        RT(2)=0.86113631
        RT(3)=-0.86113631
        RT(4)=-0.33998104
       CASE(5)
        WT(1)=0.23692689
        WT(2)=0.47862867
        WT(3)=0.56888889
        WT(4)=0.47862867
        WT(5)=0.23692689
        RT(1)=0.90617985
        RT(2)=0.53846931
        RT(3)=0.D0
        RT(4)=-0.53846931
        RT(5)=-0.90617985
	 CASE(6)
	  WT(1)=0.17132449
	  WT(2)=0.36076157
	  WT(3)=0.46791393
	  WT(4)=0.46791393
	  WT(5)=0.36076157
	  WT(6)=0.17132449
	  RT(1)=0.93246951
	  RT(2)=0.66120938
	  RT(3)=0.23861918
	  RT(4)=-0.23861918
	  RT(5)=-0.66120938
	  RT(6)=-0.9346951
       CASE(8)
        WT(1)=0.1012285362903763D0
        WT(2)=0.2223810344533745D0	
        WT(3)=0.3137066458778873D0
        WT(4)=0.3626837833783620D0
        
        WT(8)=0.1012285362903763D0
        WT(7)=0.2223810344533745D0
        WT(6)=0.3137066458778873D0
        WT(5)=0.3626837833783620D0
        
        RT(1)=0.9602898564975363D0
        RT(2)=0.7966664774136267D0
        RT(3)=0.5255324099163290D0
        RT(4)=0.1834346424956498D0
        
        RT(8)=-0.9602898564975363D0
        RT(7)=-0.7966664774136267D0
        RT(6)=-0.5255324099163290D0
        RT(5)=-0.1834346424956498D0
       CASE(10)
        WT(1)=0.D06667134
        WT(2)=0.14945134
        WT(3)=0.21908636
        WT(4)=0.26926671
        WT(5)=0.29552422
        WT(10)=0.D06667134
        WT(9)=0.14945134
        WT(8)=0.21908636
        WT(7)=0.26926671
        WT(6)=0.29552422
        RT(1)=0.97390652
        RT(2)=0.86506336
        RT(3)=0.67940956
        RT(4)=0.43339539
        RT(5)=0.14887433
        RT(10)=-0.97390652
        RT(9)=-0.86506336
        RT(8)=-0.67940956
        RT(7)=-0.43339539
        RT(6)=-0.14887433
      END SELECT

      RETURN
      END
!********************************************************************
	SUBROUTINE RMSE(N,P1,P2,E2)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,N,E1LOC
	REAL*8 P1(N),P2(N),E1,E2

!	E1=MAXVAL(DABS(P1-P2))
!	E1LOC=MAXLOC(DABS(P1-P2),1)

	E2=0.D0
	DO I=1,N
	E2=E2+(P1(I)-P2(I))**2
	END DO
	E2=DSQRT(E2/N)

	RETURN
	END
!********************************************************************
	SUBROUTINE BWLOC(PX,N,X,IST,IL,IR)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,N,IST,IL,IR
	REAL*8 PX,X(N)

	DO I=1,N-1
		IF(X(I)>PX.AND.X(I+1)<=PX)THEN
		IR=IST+I
		IL=IST+I+1
		GOTO 777
		END IF
	END DO
777 CONTINUE

	RETURN
	END
!********************************************************************
	SUBROUTINE WAVE_SPD(GRAV,OMEGA,D,C)
!********************************************************************
	IMPLICIT NONE
	INTEGER I
	REAL*8 T,K,K2,GRAV,OMEGA,D,C,PI,F0,F1
	PI=DACOS(-1.D0)

	K=1.D0
	DO I=1,100
	F0=K*DTANH(K*D)-OMEGA**2/GRAV
	F1=DTANH(K*D)+K-K*(DTANH(K*D)**2)
	K2=K-(F0)/(F1)
		IF((K2-K)/K<=0.000001D0) THEN
		GOTO 717
		END IF
	K=K2
	END DO
	717 CONTINUE

	C=DSQRT(GRAV*DTANH(K*D)/K)

	RETURN
	END
!********************************************************************
SUBROUTINE COURANT(TIME,DELTTIME,NNODE,NELM,LN,NODE,DP,JCB)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,CFLOC,NNODE,NELM,LN(NELM,2)
    REAL*8 TIME,DELTTIME,U,V,VE
	REAL*8 NODE(NNODE,2),DP(NNODE,2),JCB(NELM),CN(NELM),CFL

      DO I=1,NELM
        U=DSQRT(DP(LN(I,1),1)**2+DP(LN(I,1),2)**2)
        V=DSQRT(DP(LN(I,2),1)**2+DP(LN(I,2),2)**2)
        VE=MAX(U,V)
        CN(I)=0.5D0*VE*DELTTIME/JCB(I)
      END DO
      CFL=MAXVAL(CN)
      CFLOC=MAXLOC(CN,1)
  
	!WRITE(23,*) TIME,CFL

    IF (CFL>=250.D0)THEN
    WRITE(20,*) "CFL TOO HIGH"
    WRITE(20,*) "TIME=",TIME
    WRITE(20,*) "CFL=",CFL
    WRITE(20,*) "ELEMENT #",CFLOC
    STOP
    END IF    

	RETURN
    END
!**********************************************************************
       SUBROUTINE SOLVE_BACK(NPL,PHI,PPHI,KER1,KER2,NNODE,NELEM,BUNTYP)
!**********************************************************************
!      TO SOLVE KER1*PHI=KER2*PPHI
!      PPHI=PARTIAL PHI OVER PARTIAL N
!      USING GAUSSIAN ELIMINATION WITH BACKSUBSTITUTION
!======================================================================
       IMPLICIT NONE
       INTEGER I,J,K,L,N,NPL,NNODE,NELEM(NPL),BUNTYP(NPL)
       REAL*8 PHI(NNODE),PPHI(NNODE)
       REAL*8 KER1(NNODE,NNODE),KER2(NNODE,NNODE)
       REAL*8 H1(NNODE,NNODE),Q1(NNODE),TEMP(NNODE)
       REAL*8 SUM,A,SIG,G1(NNODE,NNODE+1),P1(NNODE)

!-----PHI PPHI----         
       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               Q1(J)=PHI(J)
            ELSE
               Q1(J)=PPHI(J)
            END IF
          END DO
          N=N+(NELEM(I)+1)
       END DO
!-------------------
         DO I=1,NNODE
           N=0
           DO L=1,NPL
             DO J=K+N,(NELEM(L)+1)+N
             IF (BUNTYP(L) .EQ. 1) THEN
               H1(I,J)=KER1(I,J)  !G*UNKNOWN=H*KNOWN
               G1(I,J)=KER2(I,J)
              ELSE
               H1(I,J)=-KER2(I,J)
               G1(I,J)=-KER1(I,J)
             END IF
             END DO
            N=N+(NELEM(L)+1)
          END DO
        END DO

       DO I=1,NNODE
          TEMP(I)=0.0
          DO J=1,NNODE
          TEMP(I)=TEMP(I)+H1(I,J)*Q1(J)
          END DO
       END DO
!*************GAUSSIAN ELIMINATION WITH BACKSUBSTITUTION*********
      DO I=1,NNODE
        G1(I,NNODE+1)=TEMP(I)
      END DO
      DO I=1,NNODE
         SUM=0.0
         DO K=I,NNODE
            IF (G1(K,I) .NE. 0) THEN
               IF (K .NE. I) THEN
               IF (G1(I,I) .EQ. 0) THEN
                 WRITE(*,*) 'SOME OF THE DIAG-TERMS ARE ZERO'
                 WRITE(20,*) 'SOME OF THE DIAG-TERMS ARE ZERO'
                 STOP
               END IF
               A=G1(K,I)/G1(I,I)
               DO J=I,NNODE+1
                  G1(K,J)=G1(K,J)-A*G1(I,J)
               END DO
               END IF
            END IF
            SUM=SUM+G1(K,I)
          END DO
          IF (SUM .EQ. 0.) THEN
          WRITE(*,*) 'NO UNIQUE SOLUTION EXISTS STOP AT GAUSSELI'
          WRITE(20,*) 'NO UNIQUE SOLUTION EXISTS STOP AT GAUSSELI'
          STOP
          END IF
      END DO

      P1(NNODE)=G1(NNODE,NNODE+1)/G1(NNODE,NNODE)
      DO I=NNODE-1,1,-1
         SIG=0.0
         DO J=I+1,NNODE
            SIG=G1(I,J)*P1(J)+SIG
          END DO
         P1(I)=(G1(I,NNODE+1)-SIG)/G1(I,I)
      END DO

       K=1
       N=0
       DO I=1,NPL
          DO J=K+N,(NELEM(I)+1)+N
            IF (BUNTYP(I) .EQ. 1) THEN
               PPHI(J)=P1(J)
            ELSE
               PHI(J)=P1(J)
            END IF
          END DO
          N=N+NELEM(I)+1
       END DO

      RETURN
    END
!********************************************************************
	SUBROUTINE STABLE(TIME,NNODE,NODE,NNODE2,NODE2)
!********************************************************************
	IMPLICIT NONE
	INTEGER NNODE,NNODE2
	REAL*8 TIME,NODE(NNODE),NODE2(NNODE2)

    IF(MAXVAL(DABS(NODE))>=1000000.D0)THEN
        WRITE(20,*) 'WAVE TO HIGH'
        WRITE(*,*) 'WAVE TO HIGH'
        STOP
    ELSE IF(MAXVAL(DABS(NODE2))>=1000000.D0)THEN
        WRITE(20,*) 'PMTLD TO HIGH'
        WRITE(*,*) 'PMTLD TO HIGH'
        STOP
    END IF
    
	RETURN
    END
!********************************************************************
	SUBROUTINE PMTLD_MECHANICAL(PI,TL,TH,NDOFTLD,GRAV,A,TMW,MFIX,IFIX,HFIX,EQM,EQC,EQK,EQH,&
                        &M_ALL,C_ALL,K_ALL,K_EFF,B3,B4,Z0,Z1,Z2,Z0_IC,X0,X1,X2,FOR2,&
                        &KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT,WG1_TLD,WG2_TLD)
!********************************************************************
! THIS SUBROUNTUNE CALCULATEE THE PMTLD BY MECHANICAL MODEL THAT IS NOT INVOLVED IN THE ITERATIVE ALGORITHM
! THE FLOATING BODY IS FULLY COUPLED, THEN ITS RESPONSES ARE TAKEN AS THE GROUND EXCITATIONS TO THE MECHANICAL SYSTEMS
	IMPLICIT NONE
	INTEGER I,NDOFTLD
    INTEGER INFO,IPIV(NDOFTLD)
    REAL*8 PI,AN,TAN,GRAV,DELTTIME,TMW,MFIX,IFIX,HFIX,TL,TH
	REAL*8 A(8),Z0(3),Z1(3),Z2(3),Z0_IC(3)
    REAL*8 X0(NDOFTLD),X1(NDOFTLD),X2(NDOFTLD),FOR2(3)
    REAL*8 X0_PC(NDOFTLD),X1_PC(NDOFTLD),X2_PC(NDOFTLD)
    REAL*8 EQM(NDOFTLD),EQC(NDOFTLD),EQK(NDOFTLD),EQH(NDOFTLD)
    REAL*8 M_ALL(NDOFTLD,NDOFTLD),C_ALL(NDOFTLD,NDOFTLD),K_ALL(NDOFTLD,NDOFTLD)
    REAL*8 K_EFF(NDOFTLD,NDOFTLD),F_EFF(NDOFTLD),F(NDOFTLD)
    REAL*8 B3(NDOFTLD),B4(NDOFTLD)
    REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT,WG1_TLD,WG2_TLD
    REAL*8 FK,FC,FI
    
!--- SOLVE DISPLACEMENT OF EQUIVALENT MASSES BY NEWMARK
    F=-B3*Z2(1)+B4*Z2(3)
    F_EFF=F+MATMUL(M_ALL,(A(1)*X0+A(3)*X1+A(4)*X2))+MATMUL(C_ALL,(A(2)*X0+A(5)*X1+A(6)*X2))
    CALL DGESV(NDOFTLD,1,K_EFF,NDOFTLD,IPIV,F_EFF,NDOFTLD,INFO)

    X0_PC=F_EFF        
    X2_PC=A(1)*(X0_PC-X0)-A(3)*X1-A(4)*X2
    X1_PC=X1+A(7)*X2+A(8)*X2_PC

!--- SOLVE TLD REACTIONS FX, FY, MZ
    FOR2(1)=0.D0
    FOR2(2)=-TMW*GRAV
    FOR2(3)=0.D0
    DO I=1,NDOFTLD
        FK=EQK(I)*X0_PC(I) ! SRPING FORCE !EQK(I)*X0(I)
        FC=EQC(I)*X1_PC(I) ! DAMPING FORCE !EQC(I)*X1(I)
        FI=EQM(I)*EQH(I)*Z2(3) ! INERTIA FORCE DUE TO ANGULAR MOTION

        ! sloshing reaction to the body, note that Counterclockwise moment is + 
        FOR2(1)=FOR2(1)+FK+FC+FI
        FOR2(3)=FOR2(3)-(FK+FC+FI)*EQH(I)
    END DO
    FOR2(1)=FOR2(1)+MFIX*HFIX*Z2(3)
    FOR2(3)=FOR2(3)-(IFIX+MFIX*HFIX**2)*Z2(3)
    
!--- RETURN NEW DISPLACEMENT
    X0=X0_PC
    X1=X1_PC
    X2=X2_PC

!--- CALCULATE ENERGY
    CALL ENERGY_MECH_TLD(NDOFTLD,GRAV,MFIX,IFIX,HFIX,Z0,Z1,Z2,EQM,EQC,EQK,EQH,X0,X1,X2,&
                        &KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)    
    
!--- CALCULATE WAVE ELEVATIONS
    WG1_TLD=0.D0
    WG2_TLD=0.D0
    DO I=1,NDOFTLD
        AN=(2.D0*I-1)*PI/TL
        TAN=DTANH(AN*TH)
        WG1_TLD=WG1_TLD-4.D0*TAN*X0(I)/AN/TL
        WG2_TLD=WG2_TLD+4.D0*TAN*X0(I)/AN/TL
    END DO
    
	RETURN
    END
!**********************************************************************
!   MODULE FOR PMTLD BY WEN-HUAI TSAO AT LSU DEC. 2021
!   IT IS PUT ON A FLOATING PLATFORM ALLOW 3-DOF MOTIONON (SWAY, HEAVE, PITCH)
!   INPUT: EXTERNAL EXCITATION
!   OUTPUT: FREE SURFACE DEFORMATION, SLOSHING FORCE, OVERTURNING MOMENT, ENERGY
!**********************************************************************
SUBROUTINE PMTLD_BEM(NNODE,NELM,NGA,ICON,NELEM,ME,NS,LN,BUNTYP,MU1,MU2,POR,&
                &GRAV,MU,THO,DELTTIME,TL,TH,TMW,DEP,TLDLOC,COOR,Z0,Z1,Z2,WT,SHA1,SHA2,SH,&
                &NODE,PHI,NODE_TEMP,FOR,KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT,WG1_TLD,WG2_TLD,&
                &LDP1,LDP2,LDPH1,LDPH2)
IMPLICIT NONE
!-----PARAMETERS ONLY USED HERE
INTEGER I,J,IDP1,IDP2
REAL*8 P_ATM
REAL*8 KER1(NNODE,NNODE),KER2(NNODE,NNODE)
REAL*8 NORM(NELM,2),JCB(NELM),LENG(NELM)
REAL*8 PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE)
REAL*8 DP(NNODE,2),D2PDT(NNODE),D2P(NNODE,2)
REAL*8 DPDS(NNODE),DPDT(NNODE),PR(NNODE),ACCMO(NNODE)
REAL*8 G1(NNODE,NNODE),H1(NNODE,NNODE),EYE(NNODE)

!-----INPUT PARAMETERS
INTEGER NNODE,NELM,NGA,ICON,NELEM(4),ME(4),NS(4),LN(NELM,2),BUNTYP(4)
REAL*8 MU1,MU2,POR,GRAV,MU,THO,DELTTIME,TL,TH,TMW,DEP,TLDLOC(2)
REAL*8 COOR(4,2),NODE_TEMP(NNODE,2),Z0(3),Z1(3),Z2(3)
REAL*8 WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)

!-----OUTPUT PARAMETERS
REAL*8 KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT
REAL*8 NODE(NNODE,2),PHI(NNODE),FOR(3)
REAL*8 WG1_TLD,WG2_TLD,LDP1,LDP2,LDPH1,LDPH2

EYE=1.D0

!---SET PMTLD BIE
CALL KERNEL(KER1,KER2,NODE,NORM,JCB,LENG,LN,NNODE,NELM,NGA,SHA1,SHA2,SH,WT,EYE)

!---SOLVE 1ST-ORDER TERM
CALL BOUND_TLD(PHI,PPHI,NNODE,NELM,NS,ME,LN,NODE,NORM,Z0,Z1)
CALL SOLVE_LAPACK(4,PHI,PPHI,KER1,KER2,NNODE,NELEM,BUNTYP)
!CALL SOLVE_LAPACK2_1(4,PHI,PPHI,KER1,KER2,G1,H1,NNODE,NELEM,BUNTYP)
CALL TAYES1_TLD(NNODE,NELM,ME,NS,LN,NODE,NORM,JCB,PHI,PPHI,DPDS,DP,PHIT,DPDT,GRAV,MU1,MU2,POR,Z0,Z1,DEP)
 
!---SOLVE 2ND-ORDER TERM
CALL ACCBC_TLD(NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI,PPHI,DP,ACCMO)
CALL BOUNDT_TLD(NNODE,NELM,NS,ME,LN,NODE,NORM,PHIT,PPHIT,ACCMO,Z0,Z1,Z2)
CALL SOLVE_LAPACK(4,PHIT,PPHIT,KER1,KER2,NNODE,NELEM,BUNTYP)
!CALL SOLVE_LAPACK2_2(4,PHIT,PPHIT,G1,H1,NNODE,NELEM,BUNTYP)
CALL TAYES2_TLD(NNODE,NELM,NS,ME,LN,NODE,NORM,JCB,PHI,PPHI,PHIT,PPHIT,&
                &DP,DPDS,DPDT,D2PDT,D2P,DELTTIME,GRAV,Z2)

!---CALCULATE PRESSURE AND FORCE TO THE BODY
CALL PRESSURE_TLD(ICON,DEP,THO,GRAV,NNODE,NS,NODE,PHIT,DP,PR,P_ATM,IDP1,IDP2,LDP1,LDP2)
CALL FORCE_TLD(NNODE,NELM,ME,LN,NODE,NORM,JCB,PR,Z0,POR,FOR)

!---REMESH FREE SURFACE OF PMTLD
CALL REMESH_TLD(NNODE,NELM,NELEM,ME,NS,NODE,NORM,DP,D2P,PHI,DPDT,D2PDT,DELTTIME,Z0,TL,TLDLOC)

!---CALCULATE ENERGY OF PMTLD
CALL ENERGY_TLD(NNODE,NELEM,NELM,NS,LN,NGA,NODE,PHI,PPHI,PHIT,PPHIT,DP,PR,&
                &NORM,JCB,WT,SH,SHA1,SHA2,POR,GRAV,THO,Z0,Z1,NODE_TEMP,KE,PE,TE,WORK,PE0,DTDT,DVDT,DEDT,DWDT)

!---CALCULATE WAVE ELEVATIONS AT LEFT- AND RIGHT-SIDE TANK WALL
WG1_TLD=DSQRT((NODE(1,1)-NODE(NS(3),1))**2+(NODE(1,2)-NODE(NS(3),2))**2)-TH
WG2_TLD=DSQRT((NODE(NS(1),1)-NODE(NS(2),1))**2+(NODE(NS(1),2)-NODE(NS(2),2))**2)-TH

!---CALCULATE LOCATION OF THE LOCAL MAX DYNAMIC PRESSURE
LDPH1=DSQRT((NODE(IDP1,1)-NODE(NS(3),1))**2+(NODE(IDP1,2)-NODE(NS(3),2))**2)
LDPH2=DSQRT((NODE(IDP2,1)-NODE(NS(2),1))**2+(NODE(IDP2,2)-NODE(NS(2),2))**2)

    RETURN
    END
!**********************************************************************
SUBROUTINE REMESH_TLD(NNODE,NELM,NELEM,ME,NS,NODE,NORM,DP,D2P,PHI,DPDT,D2PDT,DELTTIME,Z0,TL,TLDLOC)
!**********************************************************************
      IMPLICIT NONE
      INTEGER I,K,NELM,NNODE,NELEM(4),ME(4),NS(4)
      REAL*8 TL_TEMP,SX,SY,DELT,DELTTIME,TL,TLDLOC(2)
      REAL*8 Z0(3),Q(2,2),CR(2),CL(2),HL,HR,S1,S2,XTEMP
      REAL*8 NODE(NNODE,2),NORM(NELM,2),DP(NNODE,2),D2P(NNODE,2)
      REAL*8 PHI(NNODE),DPDT(NNODE),D2PDT(NNODE)

!-----REMESH FREE SURFACE NODE-----
    DO I=1,NS(1)
	NODE(I,1)=NODE(I,1)+DP(I,1)*DELTTIME+0.5D0*D2P(I,1)*DELTTIME**2
    NODE(I,2)=NODE(I,2)+DP(I,2)*DELTTIME+0.5D0*D2P(I,2)*DELTTIME**2
	PHI(I)=PHI(I)+DELTTIME*DPDT(I)+0.5D0*D2PDT(I)*DELTTIME**2
    END DO

!---CHECK IF THE UPDATED FREE SURFACE IS WIDER THAN TLD
!    TL_TEMP=(NODE(NS(1),1)-NODE(1,1))*DCOS(Z0(3))+(NODE(NS(1),2)-NODE(1,2))*DSIN(Z0(3))
!    IF(ABS((TL_TEMP-TL)/TL)>0.05D0)THEN
!        WRITE(*,*) 'TLD GROW WIDE'
!        WRITE(20,*) 'TLD GROW WIDE'
!        STOP
!    END IF
    
!------SET ROTATIONAL MATRIX
    S1=DCOS(Z0(3))
    S2=-DSIN(Z0(3))
    Q(1,1)=S1
    Q(1,2)=S2
    Q(2,1)=-Q(1,2)
    Q(2,2)=Q(1,1)
    
!------VECTOR OF TLD CORNER TO COG
    CR(1)=TLDLOC(1)+0.5D0*TL
    CR(2)=TLDLOC(2)
    CL(1)=TLDLOC(1)-0.5D0*TL
    CL(2)=TLDLOC(2)
    
    CR=MATMUL(Q,CR)+Z0(1:2)
    CL=MATMUL(Q,CL)+Z0(1:2)

!---CORRECT THE FREE-SURFACE END NODE REMAINS ON THE WALLS
    XTEMP=NODE(1,1)
    HL=(NODE(1,1)-CL(1))*S2+(NODE(1,2)-CL(2))*S1
    NODE(1,1)=CL(1)+HL*S2
    NODE(1,2)=CL(2)+HL*S1
    PHI(1)=PHI(1)+(PHI(2)-PHI(1))*(NODE(1,1)-XTEMP)/(NODE(2,1)-XTEMP)
    
    XTEMP=NODE(NS(1),1)
    HR=(NODE(NS(1),1)-CR(1))*S2+(NODE(NS(1),2)-CR(2))*S1
    NODE(NS(1),1)=CR(1)+HR*S2
    NODE(NS(1),2)=CR(2)+HR*S1
    PHI(NS(1))=PHI(NS(1))+(PHI(NS(1)-1)-PHI(NS(1)))*(NODE(NS(1),1)-XTEMP)/(NODE(NS(1)-1,1)-XTEMP)
    
!------REMESH FOR TLD RIGHT SIDE
    DELT=DSQRT((NODE(NS(1),1)-CR(1))**2+(NODE(NS(1),2)-CR(2))**2)/NELEM(2)
    SX=-S2
    SY=-S1
    K=1
    DO I=NS(1)+1,NS(2)
        NODE(I,1)=NODE(NS(1),1)+DELT*(K-1)*SX
        NODE(I,2)=NODE(NS(1),2)+DELT*(K-1)*SY
        K=K+1
    END DO

!------REMESH FOR TLD BOTTOM
    DELT=DSQRT((CL(1)-CR(1))**2+(CL(2)-CR(2))**2)/NELEM(3)
    SX=-S1
    SY=S2
    K=1
    DO I=NS(2)+1,NS(3)
        NODE(I,1)=NODE(NS(2),1)+DELT*(K-1)*SX
        NODE(I,2)=NODE(NS(2),2)+DELT*(K-1)*SY
        K=K+1
    END DO

!------REMESH FOR TLD LEFT SIDE
    DELT=DSQRT((NODE(1,1)-CL(1))**2+(NODE(1,2)-CL(2))**2)/NELEM(4)
    SX=S2
    SY=S1
    K=1
    DO I=NS(3)+1,NNODE
        NODE(I,1)=NODE(NS(3),1)+DELT*(K-1)*SX
        NODE(I,2)=NODE(NS(3),2)+DELT*(K-1)*SY
        K=K+1
    END DO
    
    RETURN
    END
!**********************************************************************
    SUBROUTINE BOUND_TLD(PHI,PPHI,NNODE,NELM,NS,ME,LN,NODE,NORM,Z0,Z1)
!**********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,NNODE,NELM,NS(4),ME(4),LN(NELM,2)
    REAL*8 DX,DY,VX,VY
    REAL*8 NODE(NNODE,2),NORM(NELM,2),PHI(NNODE),PPHI(NNODE),Z0(3),Z1(3)

      DO I=1,NS(1)
         PHI(I)=PHI(I)
         PPHI(I)=0.0
      END DO

      DO I=2,4
          DO J=ME(I-1)+1,ME(I)
              DO K=1,2
                  DX=NODE(LN(J,K),1)-Z0(1)
                  DY=NODE(LN(J,K),2)-Z0(2)
                  VX=Z1(1)-Z1(3)*DY
                  VY=Z1(2)+Z1(3)*DX
                  PPHI(LN(J,K))=VX*NORM(J,1)+VY*NORM(J,2)
                  PHI(LN(J,K))=0.D0     
              END DO
          END DO
      END DO

      RETURN
      END 
!********************************************************************
SUBROUTINE TAYES1_TLD(NNODE,NELM,ME,NS,LN,NODE,NORM,JCB,PHI,PPHI,DPDS,DP,PHIT,DPDT,GRAV,MU1,MU2,POR,Z0,Z1,DEP)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,J,K,NNODE,NELM,ME(4),NS(4),LN(NELM,2)
    REAL*8 GRAV,MU1,MU2,POR,DEP,TEMP1,TEMP2,DX,DY,VX,VY
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE)
    REAL*8 DP(NNODE,2),DPDS(NNODE),PHIT(NNODE),DPDT(NNODE)
    REAL*8 Z0(3),Z1(3)

	DPDS=0.D0
!********************* ON FREE SURFACE *********************
    DO I=1,ME(1)
    DO J=1,2
		IF(LN(I,J).EQ.1) THEN
!            DP(LN(I,J),1)=-PPHI(NNODE)
!            DPDS(LN(I,J))=(DP(LN(I,J),1)-PPHI(LN(I,J))*NORM(I,1))/NORM(I,2)
!            DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            TEMP1=PPHI(NNODE)-PPHI(1)*(NORM(I,1)*NORM(NELM,1)+NORM(I,2)*NORM(NELM,2))
            TEMP2=NORM(I,2)*NORM(NELM,1)-NORM(I,1)*NORM(NELM,2)
            DPDS(LN(I,J))=TEMP1/TEMP2
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)                       
        ELSE IF(LN(I,J).EQ.NS(1)) THEN
            TEMP1=PPHI(NS(1)+1)-PPHI(NS(1))*(NORM(I,1)*NORM(I+1,1)+NORM(I,2)*NORM(I+1,2))
            TEMP2=NORM(I,2)*NORM(I+1,1)-NORM(I,1)*NORM(I+1,2)
            DPDS(LN(I,J))=TEMP1/TEMP2
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

DO I=1,NS(1)
!DPDT(I)=0.5D0*(DP(I,1)**2+DP(I,2)**2)-GRAV*NODE(I,2)-MU*PHI(I) !-GRAV*(NODE(I,2)-DEP)-MU*PHI(I) !
DPDT(I)=0.5*(DP(I,1)**2+DP(I,2)**2)-GRAV*(NODE(I,2)-DEP)& !-GRAV*NODE(I,2)&
        &-MU1*PHI(I)& !-POR*MU1*(PHI(I)-VEL*NODE(I,1)) ! DARCY'S LAW
        &-MU2*SQRT(DP(I,1)**2+DP(I,2)**2)*PHI(I)       ! FORCHHEMER LAW
! (PHI(I)-VEL*NODE(I,1))
PHIT(I)=DPDT(I)-(DP(I,1)**2+DP(I,2)**2)
END DO
    
!*********************ON RIGHT WALL*********************
    DO I=ME(1)+1,ME(2)
    DO J=1,2
		IF(LN(I,J).EQ.NS(1)+1) THEN
!			DPDS(LN(I,J))=-DP(NS(1),2)
!            DP(LN(I,J),1)=PPHI(LN(I,J))
!            DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            DP(LN(I,J),:)=DP(NS(1),:)
        ELSE IF(LN(I,J).EQ.NS(2)) THEN
!			DPDS(LN(I,J))=0.D0
!            DP(LN(I,J),1)=PPHI(LN(I,J))
!            DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            DX=NODE(LN(I,J),1)-Z0(1)
            DY=NODE(LN(I,J),2)-Z0(2)
            DP(LN(I,J),1)=Z1(1)-Z1(3)*DY
            DP(LN(I,J),2)=Z1(2)+Z1(3)*DX
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=PPHI(LN(I,J))
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

!*********************BOTTOM*********************
    DO I=ME(2)+1,ME(3)
    DO J=1,2
		  DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
!		  DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
!		  DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            DX=NODE(LN(I,J),1)-Z0(1)
            DY=NODE(LN(I,J),2)-Z0(2)
            DP(LN(I,J),1)=Z1(1)-Z1(3)*DY
            DP(LN(I,J),2)=Z1(2)+Z1(3)*DX
    END DO
    END DO
    
!*********************LEFT WALL*********************
    DO I=ME(3)+1,ME(4)
    DO J=1,2
		IF(LN(I,J).EQ.NS(3)+1) THEN
!			DPDS(LN(I,J))=0.D0
!			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
!			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            DX=NODE(LN(I,J),1)-Z0(1)
            DY=NODE(LN(I,J),2)-Z0(2)
            DP(LN(I,J),1)=Z1(1)-Z1(3)*DY
            DP(LN(I,J),2)=Z1(2)+Z1(3)*DX            
        ELSE IF(LN(I,J).EQ.NNODE) THEN
!			DPDS(LN(I,J))=DP(1,2)
!			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
!			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
            DP(LN(I,J),:)=DP(1,:)
		ELSE
			DPDS(LN(I,J))=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
			DP(LN(I,J),1)=DPDS(LN(I,J))*NORM(I,2)+PPHI(LN(I,J))*NORM(I,1)
			DP(LN(I,J),2)=-DPDS(LN(I,J))*NORM(I,1)+PPHI(LN(I,J))*NORM(I,2)
		END IF
    END DO
    END DO

    RETURN
    END
!**********************************************************************
SUBROUTINE BOUNDT_TLD(NNODE,NELM,NS,ME,LN,NODE,NORM,PHIT,PPHIT,ACCMO,Z0,Z1,Z2)
!**********************************************************************
       IMPLICIT NONE
       INTEGER I,J,K,NNODE,NELM,NS(4),ME(4),LN(NELM,2)
       REAL*8 DX,DY,AX,AY
       REAL*8 NODE(NNODE,2),NORM(NELM,2),PHIT(NNODE),PPHIT(NNODE),ACCMO(NNODE)
       REAL*8 Z0(3),Z1(3),Z2(3)

      DO I=1,NS(1)
       PHIT(I) =PHIT(I)
       PPHIT(I)=0.0
      END DO

      DO I=2,4
          DO J=ME(I-1)+1,ME(I)
              DO K=1,2
                  DX=NODE(LN(J,K),1)-Z0(1)
                  DY=NODE(LN(J,K),2)-Z0(2)
                  AX=Z2(1)-Z2(3)*DY-Z1(3)*Z1(3)*DX
                  AY=Z2(2)+Z2(3)*DX-Z1(3)*Z1(3)*DY
                  PPHIT(LN(J,K))=AX*NORM(J,1)+AY*NORM(J,2)+ACCMO(LN(J,K))                 
                  PHIT(LN(J,K))=0.D0
              END DO
          END DO
      END DO

      RETURN
      END
!**********************************************************************
      SUBROUTINE TAYES2_TLD(NNODE,NELM,NS,ME,LN,NODE,NORM,JCB,PHI,PPHI,PHIT,PPHIT,&
                       &DP,DPDS,DPDT,D2PDT,D2P,DELTTIME,GRAV,Z2)
!**********************************************************************
      IMPLICIT INTEGER (I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER  NNODE,NELM,NS(4),ME(4),LN(NELM,2)
      REAL*8 DELTTIME,GRAV,DPTDS,DPDNDS,Z2(3)
      REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM)
      REAL*8 PHI(NNODE),PPHI(NNODE),PHIT(NNODE),PPHIT(NNODE)
      REAL*8 DP(NNODE,2),DPDS(NNODE),DPDT(NNODE),D2PDT(NNODE),D2P(NNODE,2)

!********************* ON FREE SURFACE *********************
	DO I=1,ME(1)
	  DO J=1,2
!		IF(LN(I,J).EQ.1)THEN
!            D2P(LN(I,J),1)=0 !++++++++++++++++++++++++++++++
!            DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
!            DPTDS=(D2P(LN(I,J),1)-PPHI(1)*DPDNDS*NORM(I,2)-(DPDS(1)*DPDNDS+PPHIT(1))*NORM(1,1))/NORM(1,2)
!            D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
            
!        ELSE IF (LN(I,J).EQ.NS(1))THEN !+++++++++++++++++++++++may be revised for continu
!            DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
!			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
!			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
!			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
!		ELSE
			DPTDS=(-0.5*PHIT(LN(I,1))+0.5*PHIT(LN(I,2)))/JCB(I)
			DPDNDS=(-0.5*PPHI(LN(I,1))+0.5*PPHI(LN(I,2)))/JCB(I)
			D2P(LN(I,J),1)=(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,2)-(-DPDS(LN(I,J))*DPDNDS-PPHIT(LN(I,J)))*NORM(I,1)
			D2P(LN(I,J),2)=(PPHIT(LN(I,J))+DPDS(LN(I,J))*DPDNDS)*NORM(I,2)-(DPTDS+PPHI(LN(I,J))*DPDNDS)*NORM(I,1)
!		END IF
		D2PDT(LN(I,J))=DP(LN(I,J),1)*D2P(LN(I,J),1)+DP(LN(I,J),2)*D2P(LN(I,J),2)-GRAV*DP(LN(I,J),2)
	  END DO
    END DO

      RETURN
    END
!********************************************************************
SUBROUTINE PRESSURE_TLD(ICON,DEP,THO,GRAV,NNODE,NS,NODE,PHIT,DP,PR,P_ATM,IDP1,IDP2,LDP1,LDP2)
!********************************************************************
      IMPLICIT NONE
      INTEGER I,ICON,NNODE,NS(4),IDP1,IDP2
      REAL*8 DEP,THO,GRAV,P1,P2,P3,P_ATM
      REAL*8 NODE(NNODE,2),PHIT(NNODE),DP(NNODE,2),PR(NNODE)
	  REAL*8 CP1(NS(1)),CP2(NS(1)),CP3(NS(1)),CP(NS(1))
      REAL*8 JP(NNODE),LDP1,LDP2

!----ATOM PRESSURE (BERNOULLI CONSTANT) ON THE FREE SURFACE
	DO I=ICON,ICON !1,NS(1) !
	CP1(I)=THO*PHIT(I)
	CP2(I)=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
	CP3(I)=THO*GRAV*(NODE(I,2)-DEP) !NODE(I,2) !
	CP(I)=CP1(I)+CP2(I)+CP3(I)
    END DO
!    WRITE(24,"(500(E15.8,1X))") TIME,CP(1:NS(1)),CP(NS(1+NFL)+1:NS(2+NFL))
    
	P_ATM=CP(ICON)

!----PRESSURE ON PMTLD
	DO I=NS(1)+1,NNODE
	P1=THO*PHIT(I)
	P2=THO*0.5D0*(DP(I,1)**2+DP(I,2)**2)
	P3=THO*GRAV*(NODE(I,2)-DEP) !NODE(I,2) !
	PR(I)=P_ATM-(P1+P2+P3)
    JP(I)=P1+P2
    END DO
    
!----CALCULATE LOCAL MAXIMUM OF THE DYNAMIC PRESSURE ON WALL
    LDP1=MAXVAL(JP(NS(3)+1:NNODE))
    LDP2=MAXVAL(JP(NS(1)+1:NS(2)))
    IDP1=MAXLOC(JP(NS(3)+1:NNODE),1)+NS(3)
    IDP2=MAXLOC(JP(NS(1)+1:NS(2)),1)+NS(1)

    RETURN
    END
!********************************************************************
	SUBROUTINE FORCE_TLD(NNODE,NELM,ME,LN,NODE,NORM,JCB,PR,Z0,POR,FOR)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,NPL,NFL,NNODE,NELM,ME(4),LN(NELM,2)
	REAL*8 POR,M1,M2,P1(2),P2(2),R1(2),R2(2)
	REAL*8 Z0(3),FOR(3)
	REAL*8 NODE(NNODE,2),NORM(NELM,2),JCB(NELM),PR(NNODE)

	FOR=0.D0
	DO I=ME(1)+1,ME(4)
!--- FORCE ALONG X- AND Y-DIRECTION
        P1(1)=PR(LN(I,1))*NORM(I,1)
        P1(2)=PR(LN(I,1))*NORM(I,2)
        P2(1)=PR(LN(I,2))*NORM(I,1)
        P2(2)=PR(LN(I,2))*NORM(I,2)     
		FOR(1)=FOR(1)+POR*JCB(I)*(P1(1)+P2(1)) ! NOTE JCB=0.5*LENG
		FOR(2)=FOR(2)+POR*JCB(I)*(P1(2)+P2(2))
!--- MOMENT ALONG Z-DIRECTION
		R1(1)=NODE(LN(I,1),1)-Z0(1)
		R1(2)=NODE(LN(I,1),2)-Z0(2)
		R2(1)=NODE(LN(I,2),1)-Z0(1)
		R2(2)=NODE(LN(I,2),2)-Z0(2)
        M1=R1(1)*P1(2)-R1(2)*P1(1)
        M2=R2(1)*P2(2)-R2(2)*P2(1)
		FOR(3)=FOR(3)+POR*JCB(I)*(M1+M2)
    END DO
    
	RETURN
    END
!********************************************************************
      SUBROUTINE ACCBC_TLD(NNODE,NELM,NELEM,ME,LN,NORM,JCB,PHI,PPHI,DP,ACCMO)
!********************************************************************
!-------------------------------------------
! THIS SUBROUTINE USE KO 2007 EQUATION
!-------------------------------------------
    IMPLICIT NONE
    INTEGER I,J,K,N,NPL,NNODE,NELM,NELEM(4),ME(4),LN(NELM,2)
    REAL*8 DPNDX,DPNDY,DPNDS,DPDS
	REAL*8 NORM(NELM,2),JCB(NELM),PHI(NNODE),PPHI(NNODE),DP(NNODE,2),ACCMO(NNODE)
N=0
DO K=1,4
  DO I=N+1,ME(K)
    DO J=1,2
		DPNDS=(-0.5D0*PPHI(LN(I,1))+0.5D0*PPHI(LN(I,2)))/JCB(I)
		DPDS=(-0.5D0*PHI(LN(I,1))+0.5D0*PHI(LN(I,2)))/JCB(I)
        ACCMO(LN(I,J))=-DPNDS*DPDS ! PHINN=PHISS=0 FOR LINEAR ELEMENT
!		DPNDX=DPNDS*NORM(I,2)	
!		DPNDY=-DPNDS*NORM(I,1)
!		ACCMO(LN(I,J))=DP(LN(I,J),1)*DPNDX+DP(LN(I,J),2)*DPNDY
    END DO
  END DO
  N=ME(K)
END DO

      RETURN
    END
!********************************************************************
	SUBROUTINE MECH_MODEL_SYS_UNCOUPLED(PI,N,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,&
                                       &EQM,EQC,EQK,EQH,M_ALL2,C_ALL2,K_ALL2,A,K_EFF2,B3,B4)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,N
	REAL*8 PI,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,AN,BN,WN,SIN,TAN,TEMP,TEMP2
    REAL*8 EQM(N),EQC(N),EQK(N),EQH(N),M_ALL2(N,N),C_ALL2(N,N),K_ALL2(N,N)
    REAL*8 A(8),K_EFF2(N,N),B3(N),B4(N)

    MFIX=THO*POR*TL*TH
    HFIX=POR*THO*(TL*TH**2/2.D0+TL**3/12.D0)
	DO I=1,N
        AN=PI*(2*I-1)/TL
        SIN=DSINH(AN*TH)
        TAN=DTANH(AN*TH)
        WN=DSQRT(AN*GRAV*TAN)
        EQM(I)=8.D0*POR*THO*TAN/AN**3/TL
        EQC(I)=MU1*EQM(I)
        EQK(I)=EQM(I)*WN**2
        EQH(I)=TH+2.D0/AN/SIN-1.D0/AN/TAN
        MFIX=MFIX-EQM(I)
        HFIX=HFIX-EQM(I)*EQH(I)
        B3(I)=EQM(I)
        B4(I)=EQM(I)*EQH(I)
    END DO
    HFIX=HFIX/MFIX
    
    DO I=1,N
    M_ALL2(I,I)=EQM(I)
    C_ALL2(I,I)=EQC(I)
    K_ALL2(I,I)=EQK(I)
    END DO
    
    A(1)=1.D0/BETA/DELTTIME**2
    A(2)=GAMMA/BETA/DELTTIME
    A(3)=1.D0/BETA/DELTTIME
    A(4)=0.5D0/BETA-1.D0
    A(5)=GAMMA/BETA-1.D0
    A(6)=0.5D0*DELTTIME*(GAMMA/BETA-2.D0)
    A(7)=DELTTIME*(1.D0-GAMMA)
    A(8)=GAMMA*DELTTIME
    
    K_EFF2=K_ALL2+A(1)*M_ALL2+A(2)*C_ALL2
    
    TEMP=0.D0
    TEMP2=0.D0
    DO I=1,N
        AN=PI*(2*I-1)/TL
        BN=PI*(2*I-1)/TH
        TEMP=TEMP+(3.D0*DSINH(0.5D0*BN*TL)-0.5D0*BN*TL*DCOSH(0.5D0*BN*TL))/BN**5/TH/DCOSH(0.5D0*BN*TL)
        TEMP=TEMP+(2.D0*DCOSH(AN*TH)-1.D0)/AN**5/TL/DSINH(AN*TH)
        TEMP2=TEMP2+EQM(I)*EQH(I)**2
    END DO
    TEMP2=TEMP2+MFIX*HFIX**2
    TEMP=8.D0*THO*POR*TEMP
    IFIX=TEMP-TEMP2
    
	RETURN
    END
!********************************************************************
	SUBROUTINE MECH_MODEL_SYS_COUPLED(PI,N,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,&
                            &EQM,EQC,EQK,EQH,EQM_ALL,EQC_ALL,EQK_ALL,A,K_EFF,B1,B2)
!********************************************************************
	IMPLICIT NONE
	INTEGER I,N
	REAL*8 PI,GRAV,THO,GAMMA,BETA,DELTTIME,POR,TL,TH,MU1,MB,IB,MFIX,HFIX,IFIX,AN,BN,WN,SIN,TAN,TEMP,TEMP2
    REAL*8 EQM(N),EQC(N),EQK(N),EQH(N),EQM_ALL(N+1,N+1),EQC_ALL(N+1,N+1),EQK_ALL(N+1,N+1)
    REAL*8 A(8),K_EFF(N+1,N+1),B1(N+1),B2(N+1)

    B1(1)=1.D0
    MFIX=THO*POR*TL*TH
    HFIX=POR*THO*(TL*TH**2/2.D0+TL**3/12.D0)
	DO I=1,N
        AN=PI*(2*I-1)/TL
        SIN=DSINH(AN*TH)
        TAN=DTANH(AN*TH)
        WN=DSQRT(AN*GRAV*TAN)
        EQM(I)=8.D0*POR*THO*TAN/AN**3/TL
        EQC(I)=MU1*EQM(I)
        EQK(I)=EQM(I)*WN**2
        EQH(I)=TH+2.D0/AN/SIN-1.D0/AN/TAN
        MFIX=MFIX-EQM(I)
        HFIX=HFIX-EQM(I)*EQH(I)
        B2(I+1)=EQM(I)*EQH(I)
    END DO
    HFIX=HFIX/MFIX
    
    
    EQM_ALL(1,1)=MB+MFIX
    DO I=2,N+1
    EQM_ALL(I,I)=EQM(I-1)

    EQC_ALL(1,1)=EQC_ALL(1,1)+EQC(I-1)
    EQC_ALL(I,1)=-EQC(I-1)
    EQC_ALL(1,I)=-EQC(I-1)
    EQC_ALL(I,I)=EQC(I-1)

    EQK_ALL(1,1)=EQK_ALL(1,1)+EQK(I-1)
    EQK_ALL(I,1)=-EQK(I-1)
    EQK_ALL(1,I)=-EQK(I-1)
    EQK_ALL(I,I)=EQK(I-1)
    END DO
    
    A(1)=1.D0/BETA/DELTTIME**2
    A(2)=GAMMA/BETA/DELTTIME
    A(3)=1.D0/BETA/DELTTIME
    A(4)=0.5D0/BETA-1.D0
    A(5)=GAMMA/BETA-1.D0
    A(6)=0.5D0*DELTTIME*(GAMMA/BETA-2.D0)
    A(7)=DELTTIME*(1.D0-GAMMA)
    A(8)=GAMMA*DELTTIME
    
    K_EFF=EQK_ALL+A(1)*EQM_ALL+A(2)*EQC_ALL
    
    TEMP=0.D0
    TEMP2=0.D0
    DO I=1,N
        AN=PI*(2*I-1)/TL
        BN=PI*(2*I-1)/TH
        TEMP=TEMP+(3.D0*DSINH(0.5D0*BN*TL)-0.5D0*BN*TL*DCOSH(0.5D0*BN*TL))/BN**5/TH/DCOSH(0.5D0*BN*TL)
        TEMP=TEMP+(2.D0*DCOSH(AN*TH)-1.D0)/AN**5/TL/DSINH(AN*TH)
        TEMP2=TEMP2+EQM(I)*EQH(I)**2
    END DO
    TEMP2=TEMP2+MFIX*HFIX**2
    TEMP=8.D0*THO*POR*TEMP
    IFIX=TEMP-TEMP2
    
	RETURN
    END
!********************************************************************
subroutine get_walltime(wctime)
!********************************************************************
  use iso_fortran_env, only: int64
  implicit none
  integer, parameter :: dp = kind(1.0d0)
  real(dp) :: wctime
  integer(int64) :: r, c
  call system_clock(c, r)
  wctime = real(c, dp) / r
    end subroutine get_walltime
!********************************************************************
SUBROUTINE KERNEL34(KER1,KER2,KER3,KER4,KER5,NODE,NORM,JCB,DP,ACCMO,LENG,&
                &NPL,NFL,NS,ME,LN,NNODE,NELM,NGA,SHA1,SHA2,SH,WT,GRAV,THO,MB,IB,Z0,Z1,P_ATM,DEP)
!********************************************************************
      IMPLICIT NONE
      INTEGER I,J,K,L,M,N,NFL,NPL,NNODE,NS(NPL),ME(NPL),NELM,NGA,LN(NELM,2)
      REAL*8  GRAV,THO,MB,IB,RD,RP(2),RQ(2),Z0(3),Z1(3),P_ATM,DEP
      REAL*8  KER1(NNODE,NNODE),KER2(NNODE,NNODE)
      REAL*8  KER3(NNODE,NNODE),KER4(NNODE),KER5(NNODE,NNODE),NP(NNODE,2)
      REAL*8  NX,NY,TEMP,TEMP2,KAP(2),GAM(2),XFUNC(10),YFUNC(10),UFUNC(10),VFUNC(10),PXI1(2)
      REAL*8  LENG(NELM),NORM(NELM,2),JCB(NELM),NODE(NNODE,2),DP(NNODE,2),ACCMO(NNODE)
      REAL*8  WT(NGA),SHA1(NGA),SHA2(NGA),SH(2,NGA)
      REAL*8,EXTERNAL::RNRN

!***DEFINE THE NORMAL VECTOR FOR THE BODY NODE ACCORDING TO ITS NORM OF EACH ELEMENT
      NP=0.D0
    DO I = ME(1)+1,ME(NFL+1) ! LOAD POINT LN(I,L)
        DO L=1,2
            NP(LN(I,L),:)=NORM(I,:)
        END DO
    END DO
 
    
    KER3=0.D0
!***THE SURFACE KERNELS ON THE SUBMERGED BOUNDARY
    DO I = NS(1)+1,NS(NFL+1) ! LOAD POINT I
    RP(1)=NODE(I,1)-Z0(1)
    RP(2)=NODE(I,2)-Z0(2)
        DO J = ME(1)+1,ME(NFL+1) ! FIELD POINT LN(J,K)
            DO M=1,NGA
              XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
              YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
            END DO
        DO K=1,2
        KAP(K)=0.D0
            DO M=1,NGA
            RQ(1)=XFUNC(M)-Z0(1)
            RQ(2)=YFUNC(M)-Z0(2)
            KAP(K)=KAP(K)+((NP(I,1)*NORM(J,1)+NP(I,2)*NORM(J,2))/MB+&
                &RNRN(RP,NP(I,:),RQ,NORM(J,:))/IB)*JCB(J)*SH(K,M)*WT(M)
            END DO
        KER3(I,LN(J,K))=KER3(I,LN(J,K))+THO*KAP(K)
        END DO
        END DO
    END DO

    DO I=NS(1)+1,NS(4)
    TEMP=0.D0        
        DO J=1,NNODE
            TEMP=TEMP+KER3(I,J)
        END DO
        !WRITE(99,*) I,TEMP
        
    END DO
    
!    DO I = ME(1)+1,ME(NFL+1) ! LOAD POINT LN(I,L)
!    DO L=1,2
!    RP(1)=NODE(LN(I,L),1)-Z0(1)
!    RP(2)=NODE(LN(I,L),2)-Z0(2)
!        DO J = ME(1)+1,ME(NFL+1) ! FIELD POINT LN(J,K)
!            DO M=1,NGA
!              XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
!              YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
!            END DO
!        DO K=1,2
!        KAP(K)=0.D0
!            DO M=1,NGA
!            RQ(1)=XFUNC(M)-Z0(1)
!            RQ(2)=YFUNC(M)-Z0(2)
!            KAP(K)=KAP(K)+((NORM(I,1)*NORM(J,1)+NORM(I,2)*NORM(J,2))/MB+&
!                &RNRN(RP,NORM(I,:),RQ,NORM(J,:))/IB)*JCB(J)*SH(K,M)*WT(M)
!            END DO
!        KER3(LN(I,L),LN(J,K))=KER3(LN(I,L),LN(J,K))+THO*KAP(K)
!        END DO
!        END DO
!    END DO
!    END DO

    KER5=KER1+MATMUL(KER2,KER3)
    
    KER4=0.D0
!***THE SURFACE KERNELS ON THE SUBMERGED BOUNDARY
    DO I = ME(1)+1,ME(NFL+1) ! LOAD POINT LN(I,L)
    DO L=1,2
    RP(1)=NODE(LN(I,L),1)-Z0(1)
    RP(2)=NODE(LN(I,L),2)-Z0(2)
        DO J = ME(1)+1,ME(NFL+1) ! FIELD POINT LN(J,K)
            DO M=1,NGA
              XFUNC(M)=SHA1(M)*NODE(LN(J,1),1)+SHA2(M)*NODE(LN(J,2),1)
              YFUNC(M)=SHA1(M)*NODE(LN(J,1),2)+SHA2(M)*NODE(LN(J,2),2)
              UFUNC(M)=SHA1(M)*DP(LN(J,1),1)+SHA2(M)*DP(LN(J,2),1)
              VFUNC(M)=SHA1(M)*DP(LN(J,1),2)+SHA2(M)*DP(LN(J,2),2)
            END DO
        DO K=1,2
        GAM(K)=0.D0
            DO M=1,NGA
                GAM(K)=GAM(K)+(P_ATM/THO - (0.5D0*(UFUNC(M)**2+VFUNC(M)**2)+GRAV*(YFUNC(M)-DEP)))*&
                    &((NORM(I,1)*NORM(J,1)+NORM(I,2)*NORM(J,2))/MB+&
                    &RNRN(RP,NORM(I,:),RQ,NORM(J,:))/IB)*JCB(J)*SH(K,M)*WT(M)
            END DO
        KER4(LN(I,L))=KER4(LN(I,L))+THO*GAM(K)
        END DO
        END DO     
!    KER4(LN(I,L))=KER4(LN(I,L))-Z1(3)**2*(RP(1)*NORM(I,1)+RP(2)*NORM(I,2))+ACCMO(LN(I,L))-GRAV*NORM(I,2)! FREELY MOVING BODY HAS NO F_EXT AND M_EXT
    END DO
    END DO
    
    ! FREELY MOVING BODY HAS NO F_EXT AND M_EXT
    DO I=NS(1)+1,NS(1+NFL)
        RP(1)=NODE(I,1)-Z0(1)
        RP(2)=NODE(I,2)-Z0(2)   
        KER4(I)=KER4(I)-Z1(3)**2*(RP(1)*NP(I,1)+RP(2)*NP(I,2))+ACCMO(I)-GRAV*NP(I,2)
    END DO

    RETURN
    END
!********************************************************************
    SUBROUTINE GET_PPHIT(KER3,KER4,NPL,NFL,NS,NNODE,PHIT,PPHIT)
!********************************************************************
    IMPLICIT NONE
    INTEGER NFL,NPL,NNODE,NS(NPL)
    REAL*8  KER3(NNODE,NNODE),KER4(NNODE),PHIT(NNODE),PPHIT(NNODE)
    PPHIT(NS(1)+1:NS(1+NFL))=KER4(NS(1)+1:NS(1+NFL))-MATMUL(KER3(NS(1)+1:NS(1+NFL),NS(1)+1:NS(1+NFL)),PHIT(NS(1)+1:NS(1+NFL))) 
    RETURN
    END
!********************************************************************
    FUNCTION RNRN(RP,NP,RQ,NQ)
!********************************************************************
    IMPLICIT NONE
    REAL*8 RNRN,RP(2),NP(2),RQ(2),NQ(2)
    RNRN=(RP(1)*NP(2)-RP(2)*NP(1))*(RQ(1)*NQ(2)-RQ(2)*NQ(1))
    RETURN
    END
!********************************************************************
    SUBROUTINE INITIAL_PE01(NPL,NFL,NNODE,NS,NODE,THO,GRAV,MB,Z0,PE_I0,PE_I1)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,NPL,NFL,NNODE,NS(NPL)
    REAL*8 THO,GRAV,MB,PE_I0,PE_I1
    REAL*8 NODE(NNODE,2),Z0(3)
    REAL*8 AREA1,AREA2,G1,G2,G
    
    !---INITIAL PE OF WATER IN CHANNEL
    AREA1=NODE(1,2)*(NODE(NS(2+NFL),1)-NODE(NS(1+NFL),1)+NODE(NS(1),1))
    G1=0.5D0*NODE(1,2)
    AREA2=NODE(NS(2),2)*(NODE(NS(1+NFL),1)-NODE(NS(1),1))
    G2=0.5D0*NODE(NS(2),2)
    G=G1*AREA1/(AREA1+AREA2)+G2*AREA2/(AREA1+AREA2)
    PE_I0=THO*GRAV*(AREA1+AREA2)*G
    
    !---INITIAL PE OF BODY
    PE_I1=MB*GRAV*Z0(2)
    
    RETURN
    END
!********************************************************************
    SUBROUTINE INITIAL_PE2(NNODE2,NODE2,NS2,MW,THO,GRAV,PE_I2)
!********************************************************************
    IMPLICIT NONE
    INTEGER I,NNODE2,NS2(4)
    REAL*8 THO,GRAV,PE_I2,NODE2(NNODE2,2),MW
    REAL*8 A(2),B(2),AREA1,AREA2,G1,G2,G

    !---INITIAL PE OF TLD
    A=NODE2(NS2(1),:)-NODE2(1,:)
    B=NODE2(NS2(2),:)-NODE2(1,:)
    AREA1=0.5D0*DABS(A(1)*B(2)-A(2)*B(1))
    G1=(NODE2(1,2)+NODE2(NS2(1),2)+NODE2(NS2(2),2))/3.D0
    A=NODE2(NS2(3),:)-NODE2(1,:)
    B=NODE2(NS2(2),:)-NODE2(1,:)
    AREA2=0.5D0*DABS(A(1)*B(2)-A(2)*B(1))
    G2=(NODE2(1,2)+NODE2(NS2(2),2)+NODE2(NS2(3),2))/3.D0
    G=G1*AREA1/(AREA1+AREA2)+G2*AREA2/(AREA1+AREA2)
    PE_I2=MW*GRAV*G
    
    RETURN
    END
!============================================================    
  subroutine inverse(a,c,n)
!-----------------------------------------------------------
! Inverse matrix
! Method: Based on Doolittle LU factorization for Ax=b
! Alex G. December 2009
!-----------------------------------------------------------
! input ...
! a(n,n) - array of coefficients for matrix A
! n      - dimension
! output ...
! c(n,n) - inverse matrix of A
! comments ...
! the original matrix a(n,n) will be destroyed 
! during the calculation
!===========================================================
implicit none 
integer n
double precision a(n,n), c(n,n)
double precision L(n,n), U(n,n), b(n), d(n), x(n)
double precision coeff
integer i, j, k

! step 0: initialization for matrices L and U and b
! Fortran 90/95 aloows such operations on matrices
L=0.0
U=0.0
b=0.0

! step 1: forward elimination
do k=1, n-1
   do i=k+1,n
      coeff=a(i,k)/a(k,k)
      L(i,k) = coeff
      do j=k+1,n
         a(i,j) = a(i,j)-coeff*a(k,j)
      end do
   end do
end do

! Step 2: prepare L and U matrices 
! L matrix is a matrix of the elimination coefficient
! + the diagonal elements are 1.0
do i=1,n
  L(i,i) = 1.0
end do
! U matrix is the upper triangular part of A
do j=1,n
  do i=1,j
    U(i,j) = a(i,j)
  end do
end do

! Step 3: compute columns of the inverse matrix C
do k=1,n
  b(k)=1.0
  d(1) = b(1)
! Step 3a: Solve Ld=b using the forward substitution
  do i=2,n
    d(i)=b(i)
    do j=1,i-1
      d(i) = d(i) - L(i,j)*d(j)
    end do
  end do
! Step 3b: Solve Ux=d using the back substitution
  x(n)=d(n)/U(n,n)
  do i = n-1,1,-1
    x(i) = d(i)
    do j=n,i+1,-1
      x(i)=x(i)-U(i,j)*x(j)
    end do
    x(i) = x(i)/u(i,i)
  end do
! Step 3c: fill the solutions x(n) into column k of C
  do i=1,n
    c(i,k) = x(i)
  end do
  b(k)=0.0
end do
end subroutine inverse